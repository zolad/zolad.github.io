{"pages":[],"posts":[{"title":"Android Camera Driver平台(展讯、MTK)移植适配经验","text":"记录在展讯9820，MTK6739平台配置Camera驱动的经验 展讯平台1.项目对应kernel/dts文件配置12345678910111213141516171819202122232425262728293031&amp;i2c0 { status = \"okay\"; clock-frequency = &lt;400000&gt;; sensor_main: sensor-main@3c { compatible = \"sprd,sensor-main\"; reg = &lt;0x3c&gt;; clock-names = \"clk_src\", \"sensor_eb\", \"clk_96m\", \"clk_76m8\", \"clk_48m\", \"clk_26m\"; clocks = &lt;&amp;clk_sensor0&gt;, &lt;&amp;clk_mm_ckg_gates 1&gt;, &lt;&amp;clk_twpll_96m&gt;, &lt;&amp;clk_twpll_76m8&gt;, &lt;&amp;clk_twpll_48m&gt;, &lt;&amp;ext_26m&gt;; vddio-supply = &lt;&amp;vddcamio&gt;; vddcama-supply = &lt;&amp;vddcama&gt;; vddcamd-supply = &lt;&amp;vddcamd&gt;; vddcammot-supply = &lt;&amp;vddcammot&gt;; reset-gpios = &lt;&amp;ap_gpio 37 0&gt;; power-down-gpios = &lt;&amp;ap_gpio 39 0&gt;; host = \"dcam0\"; port { sensor_main_0: endpoint { remote-endpoint = &lt;&amp;phy0_out&gt;; }; }; };}; (1).compatible = “sprd,sensor-main”， 这里不需要配摄像头的I2C Device Address，alps/kernel/drivers/misc/sprd_camera/sensor/sprd_sensor_drv.c 会读取这里的id进行处理具体的I2C地址在sensor驱动中配置 (2).reset-gpios，power-down-gpios可通过查看机器板子的原理图来确定对应gpio的引脚修改 2.项目对应device/../../BoardConfig.mk配置(1).配上前后置摄像头对应Camera Sensor的型号，如：CAMERA_SENSOR_TYPE_BACK := “sp2509 c2590”CAMERA_SENSOR_TYPE_FRONT := “gc030a” (2).若模组厂打样时摄像头拍照方向为横屏，则TARGET_BOARD_BACK_CAMERA_ROTATION/TARGET_BOARD_FRONT_CAMERA_ROTATION设置为false，否则设置为true。 (3).配置Camera支持的分辨率 123#select camera 2M,3M,5M,8M,13M,16M,21MCAMERA_SUPPORT_SIZE := 2MFRONT_CAMERA_SUPPORT_SIZE := 2M 3.vendor/sprd/../../libcamera配置和添加Camera驱动代码(1).在vendor/sprd/../../libcamera/sensor下放置已经适配了平台的sensor_drv代码，如果没有已经适配了平台的驱动代码，那只能按平台已有的驱动代码为模板按硬件文档进行适配修改。注意修改时尽量按平台已有的camera驱动代码为规范。这方面可以自己修改也可以找FAE帮忙。 (2).修改vendor/sprd/../../libcamera/sensorsensor_cfg.c，配置新Camera 12345678#ifdef OV8856extern SENSOR_INFO_T g_ov8856_mipi_raw_info;#endif在对应的sensor_infor_tab添加配置，分别是camera module name/camera name/sensor info/af/otp：#ifdef OV8856 {MODULE_SUNNY, \"ov8856\", &amp;g_ov8856_mipi_raw_info, {&amp;dw9763a_drv_entry, 0}, &amp;ov8856_cmk_drv_entry},#endif MTK平台1.kernel-4.4/drivers/misc/mediatek/imgsensor/inc/kd_imgsensor.h配置123#define S5K4H8_SENSOR_ID 0x4088#define SENSOR_DRVNAME_S5K4H8_MIPI_RAW \"s5k4h8_mipi_raw\" 2.项目对应kernel-4.4/arch/arm/configs/…/xxx_defconfig配置可通过查看device目录下项目mk文件里 KERNEL_DEFCONFIG 指向的是哪个config文件CONFIG_CUSTOM_KERNEL_IMGSENSOR=”s5k4h8_mipi_raw” 带debug标签的用于编译过程中查看调试信息 3.项目对应ProjectConfig.mk配置1234CUSTOM_HAL_IMGSENSOR = s5k4h8_mipi_rawCUSTOM_HAL_MAIN_IMGSENSOR = s5k4h8_mipi_rawCUSTOM_KERNEL_IMGSENSOR = s5k4h8_mipi_rawCUSTOM_KERNEL_MAIN_IMGSENSOR = s5k4h8_mipi_raw 4.kernel-4.4/drivers/misc/mediatek/imgsensor/src/xxx/xxx/imgsensor_sensor_list.c添加123#if defined(S5K4H8_MIPI_RAW) {S5K4H8_SENSOR_ID, SENSOR_DRVNAME_S5K4H8_MIPI_RAW, S5K4H8_MIPI_RAW_SensorInit},#endif 5.kernel-4.4/drivers/misc/mediatek/imgsensor/src/xxx/xxx/imgsensor_sensor_list.h添加1UINT32 S5K4H8_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc); 6.kernel-4.4/drivers/misc/mediatek/imgsensor/src/xxx/xxx 配置和添加Camera sensor驱动代码7.kernel-4.4/drivers/misc/mediatek/imgsensor/src/xxx/xxx/imgsensor_cfg_table.c 配置上下电时序12345678910111213141516#if defined(S5K4H8_MIPI_RAW) { SENSOR_DRVNAME_S5K4H8_MIPI_RAW, { {SensorMCLK, Vol_High, 0}, {PDN, Vol_Low, 5}, {RST, Vol_Low, 5}, {DVDD, Vol_1200, 0}, {AVDD, Vol_2800, 0}, {DOVDD, Vol_1800, 5}, {AFVDD, Vol_2800, 0}, {PDN, Vol_High, 5}, {RST, Vol_High, 5} }, },#endif 8.vendor/mediatek/proprietary/custom/xxxx/hal/imgsensor/ 添加对应Camera驱动代码9.vendor/mediatek/proprietary/custom/xxxx/hal/imgsensor_src/sensorlist.cpp添加123#if defined(S5K4H8_MIPI_RAW) RAW_INFO(S5K4H8_SENSOR_ID, SENSOR_DRVNAME_S5K4H8_MIPI_RAW, S5K4H8_CAM_CALGetCalData),#endif 10.vendor/mediatek/proprietary/custom/xxxx/hal/lens/src/lenslist.cpp添加#if defined(DW9714AF_S5K4H8_SUNWIN_P130) extern PFUNC_GETLENSDEFAULT pDW9714AF_S5K4H8_SUNWIN_P130_getDefaultData; #endif","link":"/2019/05/07/android_driver/camera_driver_config_experience/"},{"title":"展讯物理按键配置经验","text":"展讯系统驱动配置物理按键，首先查看硬件原理图，找到对应物理按键的管脚，比如按键5接的是gpio125 1.打开kernel/arch/arm/boot/dts/对应项目的.dts文件修改gpio_keys下的配置，gpios修改对应的gpio引脚号 1234567891011gpio_keys { key_5 { label = \"5 Key\"; linux,code = &lt;6&gt;;- gpios = &lt;&amp;ap_gpio 92 1&gt;;+ gpios = &lt;&amp;ap_gpio 125 1&gt;; gpio-key,wakeup; gpio-key,level-trigger; };} linux,code对应的就是KEY CODEgpio-key,wakeup代表按下时如果系统正在休眠会触发唤醒gpio-key,level-trigger 表示增加电平触发判断 2.打开u-boot15/board/spreadtrum/对应项目的pinmap .c文件 对照平台GPIO_Spec的xls表，找到gpio125对应的Ball Name，修改Fuction为默认gpio功能:BITS_PIN_AF(3) 12{REG_PIN_RTCK_LTE, BITS_PIN_AF(3)},{REG_MISC_PIN_RTCK_LTE, BITS_PIN_DS(1)|BIT_PIN_NULL|BIT_PIN_NUL|BIT_PIN_SLP_AP|BIT_PIN_SLP_NUL|BIT_PIN_SLP_OE},","link":"/2019/02/07/android_driver/sprd_key_driver_experience/"},{"title":"Android 实现电话号码（接听/拨号/短信）白名单","text":"我遇到一个需求，需要实现电话号码的白名单，除了通讯录里的号码，所有来电短信都要屏蔽掉。 Android 7.0后提供了一个电话号码黑名单的功能，可以拦截对应号码的电话和短信，即Android N BlockedNumberContract原生黑名单。 所以我这里就直接利用这个模块的函数，再此之上增加白名单判断。 白名单电话接听拦截和短信拦截这里直接利用BlockedNumberContract框架里的关键判断类BlockChecker，BlockChecker的isBlocked函数会返回一个bool值，根据这个bool值，BlockedNumberContract框架会决定是否拦截对应号码的电话和短信。 修改位置 frameworks\\opt\\telephony\\src\\java\\com\\android\\internal\\telephony\\BlockChecker.java 123456789101112131415161718192021222324252627282930313233343536 /** * Returns {@code true} if {@code phoneNumber} is blocked. * &lt;p&gt; * This method catches all underlying exceptions to ensure that this method never throws any * exception. */ public static boolean isBlocked(Context context, String phoneNumber) { boolean isBlocked = false; long startTimeNano = System.nanoTime(); try {+ //注释掉这部分原生判断，会读取BlockedNumberContract数据库里的名单作对比+ // if (BlockedNumberContract.SystemContract.shouldSystemBlockNumber(+ // context, phoneNumber)) {+ // Rlog.d(TAG, phoneNumber + \" is blocked.\");+ // isBlocked = true;+ // }+ //新增一个shouldBlockNumber函数，这里可以根据自己需求，从什么数据库读取白名单来判断对应号码是否该拦截+ if (shouldBlockNumber( context, phoneNumber)) {+ Log.d(TAG, phoneNumber + \" is blocked.\");+ isBlocked = true;+ } } catch (Exception e) { Rlog.e(TAG, \"Exception checking for blocked number: \" + e); } int durationMillis = (int) ((System.nanoTime() - startTimeNano) / 1000000); if (durationMillis &gt; 500 || VDBG) { Rlog.d(TAG, \"Blocked number lookup took: \" + durationMillis + \" ms.\"); } return isBlocked; } 如果不想短信受控制，可以修改frameworks/opt/telephony/src/java/com/android/internal/telephony/InboundSmsHandler.java 12345678910111213141516171819202122232425- block = BlockChecker.isBlocked(mContext, tracker.getDisplayAddress());+ // not block + // block = BlockChecker.isBlocked(mContext, tracker.getDisplayAddress());- block = BlockChecker.isBlocked(mContext,- cursor.getString(PDU_SEQUENCE_PORT_PROJECTION_INDEX_MAPPING- .get(DISPLAY_ADDRESS_COLUMN)));+ // not block + // block = BlockChecker.isBlocked(mContext,+ // cursor.getString(PDU_SEQUENCE_PORT_PROJECTION_INDEX_MAPPING+ // .get(DISPLAY_ADDRESS_COLUMN)));``` frameworks/opt/telephony/src/java/com/android/internal/telephony/WapPushOverSms.java``` - if (nInd.getFrom() != null- &amp;&amp; BlockChecker.isBlocked(mContext, nInd.getFrom().getString())) {++ // not block + // &amp;&amp; BlockChecker.isBlocked(mContext, nInd.getFrom().getString())+ if (nInd.getFrom() != null) { 电话拨号拦截修改位置 proprietary/packages/services/Telecomm/src/com/android/server/telecom/CallIntentProcessor.java 123456789101112131415161718192021222324252627 /** * Processes CALL, CALL_PRIVILEGED, and CALL_EMERGENCY intents. * * @param intent Call intent containing data about the handle to call. */ static void processOutgoingCallIntent( Context context, CallsManager callsManager, Intent intent) { if (phoneNumber != null) { if (!PhoneNumberUtils.isUriNumber(phoneNumber)) { phoneNumber = PhoneNumberUtils.convertAndStrip(phoneNumber); } }+ if (shouldBlockNumber(context,phoneNumber)) {+ + Log.d(CallIntentProcessor.class,phoneNumber + \" is blocked.\");++ return;+ } }","link":"/2019/02/08/android_java_framework/android_phone_whitelist/"},{"title":"Android Java framework各种各样的修改经验","text":"顺手记录下修改系统时的经验,网上很容易就能搜到的就不记录了 修改下拉快捷菜单栏的菜单列表:主要搜索qstile相关的类 xxxx/packages/apps/SystemUI/res/values/config.xml 123456789&lt;!-- The default tiles to display in QuickSettings --&gt;&lt;string name=\"quick_settings_tiles_default\" translatable=\"false\"&gt;wifi,bt,dnd,rotation,battery,cell,cast&lt;/string&gt;&lt;!-- Tiles native to System UI. Order should match \"quick_settings_tiles_default\" --&gt;&lt;string name=\"quick_settings_tiles_stock\" translatable=\"false\"&gt;wifi,cell,battery,dnd,rotation,bt,location,hotspot,inversion,saver,work,cast,night&lt;/string&gt; 如何在framework层获取当前api被调用时的进程对应的app的application context:ActivityThread.currentActivityThread().getApplication() 去除@hide 但 make update-api和编译出错解决方法:如果make update-api报错的话要看对应方法里是不是有其他@hide的类或方法,比如参数的类是hide的,调用的api是hide的要将所有相关的变量和api都去除hide,才能update成功比如:void aaa(B bbb){ ccc(bbb);}要保证B的类和ccc函数是非hide的 如何修改系统通话UI界面:路径为：packages/apps/Dialer/java/com/android/incallui/incall/implvendor/xxxxx/proprietary/packages/apps/Dialer/java/com/android/incallui/incall/impl InCallFragment ，InCallButtonGridFragment是关键类，有很多代理类和presenter类 UsbManager在连接usb设备时需要request权限才能连接到usb设备,如何跳过申请权限的弹框,默认赋予权限呢可以修改framework下的UsbUserSettingsManager: 1234567891011121314151617181920212223242526272829 // Temporary mapping USB device name to list of UIDs with permissions for the device private final HashMap&lt;String, SparseBooleanArray&gt; mDevicePermissionMap = new HashMap&lt;&gt;(); // Temporary mapping UsbAccessory to list of UIDs with permissions for the accessory private final HashMap&lt;UsbAccessory, SparseBooleanArray&gt; mAccessoryPermissionMap = new HashMap&lt;&gt;();两个hashmap分别储存的uid和对应的usbdevice,只要存在即允许了权限 public boolean hasPermission(UsbDevice device, String packageName, int uid) { synchronized (mLock) { if (isCameraDevicePresent(device)) { //camera权限,usb camera需要额外的camera权限 if (!isCameraPermissionGranted(packageName, uid)) { return false; } } //如果是系统uid,或者mDisablePermissionDialogs 设置禁用usb权限询问框,则默认拥有权限 if (uid == Process.SYSTEM_UID || mDisablePermissionDialogs) { return true; } //获取对应usbdevice的已允许权限uid,如果uid存在则判断拥有权限 SparseBooleanArray uidList = mDevicePermissionMap.get(device.getDeviceName()); if (uidList == null) { return false; } return uidList.get(uid); } } 系统编译自定义覆盖代码资源文件： Android Overlay机制允许在不修改packages中apk的情况下，来自定义 framework/package/vendor中的资源文件，实现资源的定制。来达到显示不同的UI得目的 PRODUCT_PACKAGE_OVERLAYS := device/vendor-name/device-name/product-name/overlay Or： DEVICE_PACKAGE_OVERLAYS := device/vendor-name/device-name/common/overlay 注意只能修改xml之类的资源文件,java文件无法替换。 代码文件： 通过修改 envsetup 和 lunch执行的mk文件，比如在build/core/envsetup.mk添加复制替换代码： $(shell \\cp -rf vendor/mediatek/xxxx/Camera.java frameworks/base/core/java/android/hardware/Camera.java) 通讯录如何判断是否是sim卡储存的号码：12345678910111213 private static final String ACCOUNT_TYPE_SIM = \"SIM Account\"; private static final String ACCOUNT_TYPE_USIM = \"USIM Account\"; private static final String ACCOUNT_TYPE_RUIM = \"RUIM Account\"; private static final String ACCOUNT_TYPE_CSIM = \"CSIM Account\";private static boolean isAccountTypeIccCard(String accountTypeString) { boolean isIccCardAccount = (ACCOUNT_TYPE_SIM.equals(accountTypeString) || ACCOUNT_TYPE_USIM.equals(accountTypeString) || ACCOUNT_TYPE_RUIM.equals(accountTypeString) || ACCOUNT_TYPE_CSIM.equals(accountTypeString)); //Log.d(TAG, \"account \" + accountTypeString + \" is IccCard? \" + isIccCardAccount); return isIccCardAccount; } app监听短信接收，只能监听到短短信，监听不到长短信：检查系统短信应用Mms，长短信是需要系统短信应用去操作拼接的 修改系统蓝牙功能支持类型vendor/xxxx/proprietary/packages/apps/Bluetooth/res/values/config.xml 修改如下对应功能支持的值 123456789101112131415161718&lt;bool name=\"profile_supported_a2dp\"&gt;true&lt;/bool&gt;&lt;bool name=\"profile_supported_a2dp_sink\"&gt;false&lt;/bool&gt;&lt;bool name=\"profile_supported_hdp\"&gt;false&lt;/bool&gt;&lt;bool name=\"profile_supported_hs_hfp\"&gt;true&lt;/bool&gt;&lt;bool name=\"profile_supported_hfpclient\"&gt;false&lt;/bool&gt;&lt;bool name=\"profile_supported_hid\"&gt;false&lt;/bool&gt;&lt;bool name=\"profile_supported_opp\"&gt;false&lt;/bool&gt;&lt;bool name=\"profile_supported_pan\"&gt;false&lt;/bool&gt;&lt;bool name=\"profile_supported_pbap\"&gt;false&lt;/bool&gt;&lt;bool name=\"profile_supported_gatt\"&gt;true&lt;/bool&gt;&lt;bool name=\"pbap_include_photos_in_vcard\"&gt;false&lt;/bool&gt;&lt;bool name=\"pbap_use_profile_for_owner_vcard\"&gt;false&lt;/bool&gt;&lt;bool name=\"profile_supported_map\"&gt;false&lt;/bool&gt;&lt;bool name=\"profile_supported_avrcp_controller\"&gt;false&lt;/bool&gt;&lt;bool name=\"profile_supported_sap\"&gt;false&lt;/bool&gt;&lt;bool name=\"profile_supported_pbapclient\"&gt;false&lt;/bool&gt;&lt;bool name=\"profile_supported_mapmce\"&gt;false&lt;/bool&gt;&lt;bool name=\"profile_supported_hidd\"&gt;false&lt;/bool&gt;","link":"/2019/01/05/android_java_framework/android_java_framework_experience/"},{"title":"谈谈Android地图sdk怎么实现的","text":"国内国外有不少在Android平台上提供地图sdk的公司。大部分人使用的地图sdk里，国内有百度/高德地图，国外有谷歌地图。但是地图服务，包括地图基础绘制/路线/导航/POI/定位等，大部分地图sdk的实现都是大同小异的。这里我不想写解析地图sdk业务逻辑层实现的文章，只谈谈一般人不知道的几个点。 1.MapView是怎么实现的地图显示绘制是地图sdk最基础的部分，用户通过手势滑动放大缩小地图，在地图的基础上显示两点间的路线，地图上的商户poi点显示标注等等都要基于MapView去绘制显示。 地图绘制 先说地图的绘制，Android自带OpenGL开放图形库，支持2D,3D矢量图形的绘制。OpenGL ES 是Android绘图API。 OpenGL ES在Android上常用来做游戏开发，所以用来做2d,3d地图的绘制是绝对胜任的。 地图贴图是地图公司收集地图数据绘制出来的，一般都是公司的机密，所以地图sdk在地图绘制上的代码都是在用c/c++代码写的，在Android平台上封装成so库，让java上层只起到一个传递数据/控制/显示的功能。 对于OpenGL这个图形引擎，地图贴图就是一张张的纹理。由地图基础引擎从本地动态加载地图图片到内存，最后使用OpenGL绘制到画布上。 地图控制 OpenGL除了基础的绘制外，也提供了6种坐标系，用户的手势操作最终都会投影到模型和相机视角的变换上。 地图显示 OpenGL ES是平台通用的，在特定设备上使用需要一个中间层做适配，这个中间层就是EGL。 Display(EGLDisplay) 是对实际显示设备的抽象。Surface（EGLSurface）是对用来存储图像的内存区域 FrameBuffer 的抽象，包括 Color Buffer， Stencil Buffer ，Depth Buffer。Context (EGLContext) 存储 OpenGL ES绘图的一些状态信息。 关于EGL的详细我就不描述了，简明扼要的说，我们要绘制地图，用OpenGL ES提供的API去绘制，绘制数据的容器是Surface，绘制数据要在哪个View上显示？Android提供了GLSurfaceView。 GLSurfaceView从Android 1.5(API level 3)开始加入，继承自SurfaceView，实现了SurfaceHolder.Callback2接口，拥有SurfaceView的全部特性，也有view所有的功能和属性，特别是处理事件的能力，它主要是在SurfaceView的基础上它加入了EGL的管理，并自带了一个GLThread绘制线程（EGLContext创建GL环境所在线程即为GL线程），绘制的工作直接通过OpenGL在绘制线程进行，不会阻塞主线程，绘制的结果输出到SurfaceView所提供的Surface上，这使得GLSurfaceView也拥有了OpenGlES所提供的图形处理能力 如果你反编译地图sdk就会发现，不看外面的API封装，MapView基本都是继承GLSurfaceView类实现的。 因为GLSurfaceView拥有SurfaceView的全部特性，所以大部分地图SDK的MapView一旦放到ScrollView里拖动时就会产生黑影。 当然GLSurfaceView并不是必要的，比如有些人用TextureView模仿GLSurfaceView添加EGL实现了GLThread。也同样可以在GLTextureView上进行OpenGL的绘制显示。但GLSurfaceView在地图绘制的场景下更合适，而且从Android 1.5就支持了，剩下的就不比对了，大家可以搜下SurfaceView和TextureView的优劣。 2.路线规划/导航/POI搜索 关于路线/交通状况/POI的数据 路线/交通状况/POI点的数据实际都是保存在后台服务器的，因为这些也是地图公司持有的资源。 地图SDK提供的路线规划/POI搜索/路况显示等功能，实际都是通过网络请求从服务器获取数据，然后通过地图引擎显示在MapView上的。 当然路线的规划也是由后台服务器计算规划出来的，本地通过两个坐标点让服务器计算，服务器返回几条可行的路线数据（包括时间最优，距离最优，少步行等），Android本地只是显示这些服务器返回的结果而已。 关于导航模式 导航也是基于MapView的，只不过是业务场景比较复杂而已。路况/路线模拟图/方向/红绿灯提醒/车速等等，导航模式里涉及到数据比较多，跟服务器的交互也比较频繁。 Android地图的UI，有OpenGL绘制的部分,也有Android View上层绘制的部分。导航数据相关的部分很多是后者。 以上只是我所知道的几个点，当然有很多我没有提及，以后有机会再补充，包括地图公司一般都有自己的导航路线模拟工具，所以测试时可以记录之前行走的路线再次模拟导航，也可以自动模拟导航来触发bug。当然离开地图公司后也没什么机会再接触到相关的代码了，所以就写下这篇文章简单记录下吧。","link":"/2017/07/15/android_map/android_map_understanding/"},{"title":"Android KitKat(4.4)单独编译Kernel","text":"这篇文章教你如何在没有全部Android源码，只有kernel文件夹时编译boot.img。另外这里需要从4.4的源码或者平台源码提取一些工具。 Android源码里的Kernel文件夹是GNU协议的，所以厂家的驱动操作细节基本在其他目录（比如vendor）下的Hal代码里。 如果想熟悉Android大概编译流程的话，最直接的就是看/build/core/Makefile的代码，这样你就会清楚每个img文件是从那些文件里生成的，用的什么参数、工具也一目了然。 关于安卓各版本的差异和平台差异安卓各版本差异Android不同版本编译时，需要的JDK版本和C编译工具版本是不一样的，4.4用的JDK版本是1.6，而C的编译器版本可以查看/build/core/Makefile的代码来确认。 平台差异展讯、MTK、高通下的有些平台在编译完源码后会对img进行签名加密操作，如果涉及到签名加密最好是拥有对应平台的源码，从中提取签名加密工具和参数。 编译脚本的编写文件目录├── arm-eabi-4.8 // c编译器├── build_tools //编译相关工具├── config│ ├── kernel_config //kernel编译的config文件，需要从kernel/arch/arm/configs下找到对应机器类型的config文件，或者直接从整体源码编译后的out目录里提取│ └──xxxxx-native.dtb //kernel对应机器类型的dts文件，用来生成dt.img，需要从kernel/arch/arm/boot/dts目录里提取├── flash│ └── ramdisk.img //整体源码编译后的ramdisk.img├── kernel //源码文件├── packimage_scripts //签名加密工具，不一定需要，看平台├── build.sh //编译脚本 编写编译脚本build.sh编译的过程，简单来说，就是先根据config文件编译kernel文件夹，找到对应机器的dts文件用dtbTool生成dt.img,然后使用mkbootimg工具，合并kernel的编译结果Image、ramdis.img、dt.img生成boot.img。 最后如果需要签名加密在用签名加密工具对boot.img进行签名加密。 12345678910111213141516make -j8 -l8 -C ./kernel cleanrm -rf outmkdir outrm flash/dt.img flash/boot.img flash/boot-sign.imgcp ./config/kernel_config out/.configmake -j4 -C ./kernel ARCH=arm CROSS_COMPILE=$PWD/arm-eabi-4.8/bin/arm-eabi- O=$PWD/out/find out/arch/arm/boot/dts/ -name *.dtb ! -name xxxxx.dtb | xargs -I{} rm {}./build_tools/dtbTool -o flash/dt.img -s 2048 -p out/scripts/dtc/ out/arch/arm/boot/dts/./build_tools/mkbootimg --kernel out/arch/arm/boot/Image --ramdisk flash/ramdisk.img --cmdline console=ttyS1,115200n8 --base 0x00000000 --pagesize 2048 --dt flash/dt.img --kernel_offset 0x00008000 --ramdisk_offset 0x05400000 --output flash/boot.imgsource packimage_scripts/packimage.sh flash/boot.img &nbsp; 这里还得说下，因为平台的不同，编译过程的参数、指令、文件都可能有差异，最好是根据/build/core/Makefile里的过程走，也可以参照其他kernel编译的相关文章。","link":"/2018/10/28/android_kernel/android_kitkat_kernel_build/"},{"title":"Android启动流程-个人笔记","text":"网上关于android启动流程的文章很多，对于我个人而言想额外补充一些知识点总结下。下面是一张网上很常见的android 启动流程图： 所以我就顺着这张流程图从上到下总结一下. Boot RomBoot Rom是嵌入在ARM芯片上的，当设备按下power键上电后，设备启动加电自检后从固定的地址开始执行，随后Boot Rom加载Bootloader代码进入内存，然后执行。 BootLoaderBootLoader类似windows上的BIOS程序，嵌入式系统有很多开源的BootLoader，比如很多Android平台厂商使用的U-boot（全名An Universal boot loader）就是开源的BootLoader。 下图是Linux系统和Android系统(MTK平台)启动流程差别，左边为Linux系统，右边为Android系统(MTK平台)。 我们根据上面的对比图，可以发现Android的启动流程设计和Linux的区别。 这里先说一点，MTK平台为了防止芯片被HACK，特意加了Pre-Loader这段程序，Pre-Loader为了保护芯片包含了一些安全功能和做一些安全检查，安全检查没问题后才加载启动U-boot程序，但Pre-Loader不是所有Android平台都有的，比如展讯的一些平台就没有。 BootLoader主要工作包括配置系统Memory、加载kernel的image、传递参数给linux kernel、获取芯片信息、跳转到kernel执行。 当然BootLoader还有一些其他的工作，比如设备在关机状态下，按下开机键，此时设备执行到BootLoader层，设备有最底启动电压，BootLoader里的代码会判断当前电池电压是否满足最低启动电压，来决定是否启动设备。 还有判断进入recovery模式/充电模式/开机模式等，也是在这一层做判断。 Kernel在这一步会加载Linux内核，内核启动时，会设置缓存、被保护存储器、计划列表，加载驱动等等。设备很多硬件功能就是在这一层开始支持使用的。当内核完成系统设置，它会启动init进程。 另外linux的watchdog进程也是这时候启动的，watchdog是为了保证系统正常运行，或者从死循环，死锁等一场状态退出的一种机制。防止系统死机卡死，但如果系统在bootloader阶段卡死，那watchdog就不起作用了。 initinit进程（/system/core/init）是Linux系统第一个在用户空间创建的进程。Linux 操作系统和驱动程序运行在内核空间，应用程序运行在用户空间。 用户空间和内核空间使用的内存区域也是划分开的，也是为了避免用户空间的操作影响到内核空间。 init进程会启动一些关键的系统进程，比如servicemanager服务管理、zygote孵化程序、surfaceflinger、mediaserver、Property Service(我们常用的系统属性，System Properties就是由这个服务管理的)等。 init目录下有自己的语法脚本，比如init.rc、init.usb.rc、init.trace.rc等。 ZygoteZygote负责创建JVM的环境，工作包括创建Dalvik虚拟机实例、创建system_server进程、创建socket server进程（让其他进程和zygote进程通信）、DVM预加载初始化核心的库和资源文件。 所有apk的进程都是由Zygote fork出来的，由于是linux父子进程的关系，DVM加载的core library和资源（一般是只读的）也可以被app进程使用,app进程只需要加载自己独有的资源，这样就节省下了内存。 Linux的fork()使用写时拷贝（copy-on-write）页实现。如下图所示，创建P2子进程，内核只为P2子进程创建虚拟空间，不分配物理内存，和P1父进程共享物理空间，当P1父进程中有更改相应段的行为发生时，才为子进程分配物理空间。 所以Zygote在创建子进程前加载的资源可以直接被子进程调用，同为了避免写入资源造成重新分配问题，所以资源一般都是只读的。 Android上层的所有程序都是运行在Dalvik VM上的（ART未引入前）。DVM只执行.dex的Dalvik executable文件。每一个Android应用程序在底层都对应有一个独立的DVM实例并在其解释下执行,Java编译器编译的.class文件经过DX工具转换为.dex文件，.dex文件由类加载器处理，接着解释器根据指令集对Dalvik字节码进行解释、执行，最后交与Linux处理。 DVM通过即时编译器（JIT，just in time）将字节码转换为机器码，机器码加载到内存后执行。JIT就是在运行时（runtime）执行生成机器码并执行（比如在c语言实现的话，就是mmap一段内存，把机器码数据拷贝到这段内存里，然后用函数指针指向这段内存后执行）。 当然Android后面引入了ART取代了DVM，而在ART中，系统在安装应用时会进行一次预编译,将字节码预先编译成机器码并存储在本地，这样应用每次运行时就不需要执行编译了，运行效率也大大提升。 System ServerSystem Server进程由Zygote进程fork出来，这个进程加载了其他很多关键的Service，比如PMS、WMS、AMS等，从这一层开始，各种各样的Service会进行扫描安装apk，启动Launcher，关闭开机动画，app启动运行，窗口显示管理等等的工作，这一层开始后网上的文章已经有很多了，就不重复了。 这一篇文章注重概括android启动流程和补充一些细节，比较少讲android上层的启动知识点，时间已到深夜，晚安。","link":"/2019/05/13/android_system/android_boot_flow_self_note/"},{"title":"Android实现关机状态下充电自开机","text":"实现一个需求，在机器关机状态下，只要充电中并电量达到10%就自己开机。 修改bootloader的charge_mode流程 一开始想着既然要在充电时判断电量启动,不如就在bootloader改动,因为bootloader作为系统的引导器,在按键的触发下,会选择对应的模式往下走,比如charge_mode,fastboot_mode,normal_mode(正常启动)等. 当插入充电器时,bootloader一般会走charge_mode流程,我们直接在charge_mode的函数实现内判断当前电压是否大于最低启动电压,如果大于则判断电量,因为只有电压的情况,所以找硬件要了份电池曲线表,找到电量10%对应的电压,如果大于这个电压则进入normal_mode开机,否则继续charge_mode流程. 获取当前电压的函数和最低启动电压的值,可在bootloader/uboot目录下搜索VBAT/BAT/VOL相关的字段 比如展讯9820平台的最低启动电压的值是在uboot/include/configs/XXXX.h(对应项目头文件) 1#define LOW_BAT_VOL 3500 /*phone battery voltage low than this value will not boot up*/ 而获取当前电压的函数在sprd_battery.c 1unsigned int vbat_vol = sprdfgu_read_vbat_vol(); 修改编译刷机测试,正常实现了充电自开机,需求完成! …… 但是问题来了,测试员反馈自动开机不稳定,怎么不稳定?原本定义10%自动开机,但实际电量在1%-20%区间都有可能触发,还有30%电量还不触发的情况. 难道是获取当前电压的函数有问题?于是我加了log打印当前电压的值,bootloader的log可以通过串口输出日志看到. 结果发现获取当前电压的函数返回的值浮动很大,很不稳定,这时候只能提个case给平台商了. 平台商的回复如下: | 电池的开路电压很难通过电池工作状态下来计算出来，计算出来的误差非常大，因此我们不能通过在uboot来检测电池开路电压的方式计算电池容量是否已经冲上来了，所以我们就用电池的工作电压，充电器在位的时候3.3V，充电器不在位的时候3.4V开机，保证开机过程不会掉电 更好的实现方法:在关机充电动画处判断电压开机 充电动画的代码一般是平台厂商定制的,所以直接到vendor目录下搜索charge字段,找到charge动画相关代码.由于是充电动画相关的代码,所以肯定有获取显示电量的代码,这就节省了我们依据电压去判断电量的不准确性. 下面直接贴代码 展讯: 12345678910111213141516171819202122232425262728vendor/sprd/proprietories-source/charge/ui.cvoid *charge_thread(void *cookie) { int fd, err; char buf; int bat_stat = 0; int bat_level = 0; for (; !is_exit; ) { usleep(1000000/ PROGRESSBAR_INDETERMINATE_FPS); // update the progress bar animation, if active if (bat_stat == BATTERY_STATUS_CHARGING) { gProgressBarType = PROGRESSBAR_TYPE_INDETERMINATE; } else { gProgressBarType = PROGRESSBAR_TYPE_NORMAL; } bat_level = battery_capacity(); bat_stat = battery_status(); update_progress_locked(bat_level);+ //如果电量大于10%则开机启动+ if(bat_level &gt; 20)+ syscall(__NR_reboot, LINUX_REBOOT_MAGIC1, LINUX_REBOOT_MAGIC2, LINUX_REBOOT_CMD_RESTART2, \"charger\"); usleep(500000); } usleep(200); return NULL;} MTK: vendor/mediatek/proprietary/external/charger/charging_control.cpp","link":"/2019/04/06/android_system/android_auto_boot_when_charging/"},{"title":"Android 展讯/MTK Alarm白名单设置","text":"目前大部分应用都会通过AlarmManager设置 alarm 来定时或周期唤醒系统来做一些操作。这种随机的 alarm 唤醒会增加系统的待机功耗。所以平台厂商为了功耗优化，一方面禁止了非白名单的第三方应用在系统休眠时唤醒系统，一方面做了心跳对齐的机制（即将这些唤醒时间杂乱的alarm修改为统一时间唤醒）。 当然Android M开始也引入了Doze机制，Doze机制的白名单和平台的Alarm白名单最好都配置上对应的包名。 展讯平台修改路径：vendor\\sprd\\platform\\frameworks\\native\\data\\etc\\appPowerSaveConfig.xml 在配置文件中添加应用包名 1&lt;package name=\"com.my.app\" optimize=\"1\" alarm=\"2\" wakelock=\"2\" network=\"0\" autolaunch=\"2\" secondarylaunch=\"2\" lockscreencleanup=\"2\" consumertype=\"0\" /&gt; optimize 对应是否对该应用进行省电优化的总开关，0 为不优化，1 为优化 alarm 对应待机唤醒优化，0 对应自动，1 对应优化，2 对应不优化 wakelock 对应待机休眠优化，0 对应自动，1 对应优化，2 对应不优化 MTK平台修改路径：frameworks/base/core/java/com/mediatek/amplus/config/alarmplus.config 如果没有该文件就创建一个，在配置文件中添加应用包名 121com.my.app2com.my.app2 另外将该文件拷贝到system/etc下 123#alarmplusPRODUCT_COPY_FILES += \\vendor/mediatek/proprietary/frameworks/opt/amplus/config/alarmplus.config:system/etc/alarmplus.config:mtk","link":"/2019/04/02/android_system/android_sprd_mtk_alarm_group_whitelist/"},{"title":"Android实现USB功能裁剪和adb限制","text":"记录Android实现USB功能裁剪和adb限制的经验 USB功能剪裁首先我们要了解init.rc，init.rc会加载init.usb.rc和init.usb.configfs.rc，上层usb功能的选择会修改sys.usb.config，然后会触发init.usb.configfs.rc的选项。 以下截取了一部分init.usb.configfs.rc的代码，可以看到sys.usb.config这个属性的值会触发不同的usb模块功能。 123456789101112131415161718192021222324252627282930on property:sys.usb.ffs.ready=1 &amp;&amp; property:sys.usb.config=adb &amp;&amp; property:sys.usb.configfs=1 write /config/usb_gadget/g1/configs/b.1/strings/0x409/configuration \"adb\" symlink /config/usb_gadget/g1/functions/ffs.adb /config/usb_gadget/g1/configs/b.1/f1 write /config/usb_gadget/g1/UDC ${sys.usb.controller} setprop sys.usb.state ${sys.usb.config}on property:sys.usb.config=mtp &amp;&amp; property:sys.usb.configfs=1 write /config/usb_gadget/g1/configs/b.1/strings/0x409/configuration \"mtp\" symlink /config/usb_gadget/g1/functions/mtp.gs0 /config/usb_gadget/g1/configs/b.1/f1 write /config/usb_gadget/g1/UDC ${sys.usb.controller} setprop sys.usb.state ${sys.usb.config}on property:sys.usb.config=mtp,adb &amp;&amp; property:sys.usb.configfs=1 start adbdon property:sys.usb.ffs.ready=1 &amp;&amp; property:sys.usb.config=mtp,adb &amp;&amp; property:sys.usb.configfs=1 write /config/usb_gadget/g1/configs/b.1/strings/0x409/configuration \"mtp_adb\" symlink /config/usb_gadget/g1/functions/mtp.gs0 /config/usb_gadget/g1/configs/b.1/f1 symlink /config/usb_gadget/g1/functions/ffs.adb /config/usb_gadget/g1/configs/b.1/f2 write /config/usb_gadget/g1/UDC ${sys.usb.controller} setprop sys.usb.state ${sys.usb.config}on property:sys.usb.config=ptp &amp;&amp; property:sys.usb.configfs=1 write /config/usb_gadget/g1/configs/b.1/strings/0x409/configuration \"ptp\" symlink /config/usb_gadget/g1/functions/ptp.gs1 /config/usb_gadget/g1/configs/b.1/f1 write /config/usb_gadget/g1/UDC ${sys.usb.controller} setprop sys.usb.state ${sys.usb.config}on property:sys.usb.config=ptp,adb &amp;&amp; property:sys.usb.configfs=1 start adbd 所以我们要裁剪USB功能选择，很简单，修改这个init.usb.configfs.rc，去除一些可触发的选项。比如我的需求是只保留adb，去除所有mtp，ptp等usb功能。 那么我们新建一个文件system/core/rootdir/init.usb.configfs_limit.rc： 12345678910111213141516171819202122232425262728on property:sys.usb.config=none &amp;&amp; property:sys.usb.configfs=1 write /config/usb_gadget/g1/UDC \"none\" stop adbd setprop sys.usb.ffs.ready 0 setprop sys.usb.ffs.mtp.ready 0 write /config/usb_gadget/g1/bDeviceClass 0 write /config/usb_gadget/g1/bDeviceSubClass 0 write /config/usb_gadget/g1/bDeviceProtocol 0 rm /config/usb_gadget/g1/configs/b.1/f1 rm /config/usb_gadget/g1/configs/b.1/f2 rm /config/usb_gadget/g1/configs/b.1/f3 rmdir /config/usb_gadget/g1/functions/rndis.gs4 setprop sys.usb.state ${sys.usb.config}on property:init.svc.adbd=stopped setprop sys.usb.ffs.ready 0on property:sys.usb.config=adb &amp;&amp; property:sys.usb.configfs=1 start adbdon property:sys.usb.ffs.ready=1 &amp;&amp; property:sys.usb.config=adb &amp;&amp; property:sys.usb.configfs=1 write /config/usb_gadget/g1/configs/b.1/strings/0x409/configuration \"adb\" symlink /config/usb_gadget/g1/functions/ffs.adb /config/usb_gadget/g1/configs/b.1/f1 write /config/usb_gadget/g1/UDC ${sys.usb.controller} setprop sys.usb.state ${sys.usb.config}on property:sys.usb.config=mtp,adb &amp;&amp; property:sys.usb.configfs=1 start adbd 然后在项目mk文件里执行拷贝操作即可 12PRODUCT_COPY_FILES += \\ system/core/rootdir/init.usb.configfs_limit.rc:root/init.usb.configfs.rc adb限制客户有个需求，想要另外的开关来控制adb开启关闭，另外不想让原生的adb开关起效。 其实android上层控制adb开关，都是通过设置persist.sys.usb.config和sys.usb.config这两个属性值来控制的。如果这两个属性的值包含adb这个字段则会触发打开adb功能。 所以我们使用一个额外的属性persist.adb.enable来控制adb开关。然后我们直接修改frameworks/base/core/java/android/os/SystemProperties.java 123456789101112131415161718192021222324/** * Set the value for the given key. * @throws IllegalArgumentException if the value exceeds 92 characters */public static void set(String key, String val) { if (val != null &amp;&amp; val.length() &gt; PROP_VALUE_MAX) { throw newValueTooLargeException(key, val); } if(key.equals(USB_PERSISTENT_CONFIG_PROPERTY)||key.equals(USB_CONFIG_PROPERTY)) { if(containsFunction(val,\"adb\")&amp;&amp;getInt(\"persist.adb.enable\", 0)&gt;0){ val = \"adb\"; }else{ val = \"none\"; } } if (TRACK_KEY_ACCESS) onKeyAccess(key); native_set(key, val);} 这样就可以通过persist.adb.enable属性来控制adb的开启和关闭，而原生的adb开关则不会起作用。","link":"/2018/12/22/android_system/android_usb_function_cut_adb_limit/"},{"title":"Android Camera软件框架(一)-Application Framework->Camera Service","text":"Camera根据Android架构从上至下可分为: 1.Applications: 最上层的应用； 2.Application Framework: 主要为Applications提供API; 3.JNI: 使Application Framework和Libraries可交互 4.Libraries: 包括Camera Framework和Camera Service(camera service和camera client); 5.HAL: 硬件抽象层, 用来链接driver和 Camera Service; 6.Kernel: image sensor driver的实现. 其中2-4的部分属于Android系统原生架构，平台厂商一般不改动或做少许拓展。而HAL层承上启下，涉及到图像数据处理和传输，是平台厂商自主设计的部分，不同平台框架差别很大。 Camera Api分Api1和Api2，5.0后支持Api2。Api2支持的功能更多，更适合用来定制Camera类应用。 目前Android Camera hal版本主要有v1和v3,v3将更多的工作集中在了Framework去完成，，从而与HAL的交互的数据信息更少，也进一步减轻了一些在旧版本中HAL层所需要做的事情，也更加模块化。 这里就几个组合，Api1-&gt;Hal1,Api1-&gt;Hal3,Api2-&gt;Hal3,Android P版本的新项目Api1都强制使用Hal3，但从老项目比如O版本升级上来的继续使用Hal1. 下面分别分析Camera Api1和Api2对Camera Service的调用。 Camera Api1Camera.java -&gt; CameraService 上图是Camera1接口openCamera操作的调用流程。 其中JNI调用Camera::connect()请求CameraService服务。Camera类继承模板类CameraBase和BnCameraClient。首先调用模板类的connect()函数，在函数中向ServiceManager获取Camera服务信息，并生成CameraService服务代理BpCameraService（/frameworks/av/camera/ICameraService.cpp），然后通过Binder通信发送CONNECT命令，当BnCameraService收到CONNECT命令后调用CameraService的connect()成员函数来做相应的处理。 BpCameraService的connect()成员函数。首先将传递过来的Camera对象转换成IBinder类型，将调用的参数写到Parcel中，通过BpBinder的transact()函数发送消息，然后由BnCameraService去响应该连接，最后就是等待服务端返回，如果成功这里为我们生成一个BpCamera实例。 123456remote()-&gt;transact(BnCameraService::CONNECT, data, &amp;reply); // CONNECT命令if (readExceptionCode(reply)) return -EPROTO;status_t status = reply.readInt32();if (reply.readInt32() != 0) { device = interface_cast&lt;ICamera&gt;(reply.readStrongBinder()); // client端读出server返回的binder，device为BpCamera(ICamera)} BpCameraService是client端的代理接口，通过transact将处理请求传给BnCameraService（BnCameraService） IXXXService为client端的代理接口BpXXXService和server端的BnXXXService的共同接口类，这个共同接口类的目的就是保证service方法在C/S两端的一致性。 CameraService -&gt; HALCameraService在hal1老版本的实现里，是通过hw_get_module(CAMERA_HARDWARE_MODULE_ID)打开对应Camera hal层动态库，老版本Hal层调用的原理是dlopen()。 新版hal3则是通过HIDL连接Hal层。HIDL又分直通式和绑定式，直通式的原理还是dlopen（只是用HIDL的方式封装了），所以直通式HIDL下hal层还是跟service在同一个进程，而绑定式HIDL使用Binder方式进行IPC，所以service和hal层运行在不同进程。 源码位置：frameworks/base/core/java/android/hardware/Camera.javaCamera.java为App直接调用的接口 frameworks/base/core/jni/android_hardware_Camera.cpp此部分为Java调用的JNI native部分代码 frameworks/av/camera/Camera.cppframeworks/av/camera/CameraBase.cppApp连接到CameraService部分的Client frameworks/av/services/camera/libcameraservice/CameraService.cppframeworks/av/services/camera/libcameraservice/CameraService.h这部分是CameraService的代码, App通过Binder来连接 frameworks/av/services/camera/libcameraservice/api1/CameraClient.cpp这部分是CameraService端的Client, 用于调用HAL层的接口 frameworks/av/services/camera/libcameraservice/device1/CameraHardwareInterface.hGoogle定义的HAL接口, 由芯片厂商去实现, 以上代码是Google写的Android系统代码, HAL层及以下则是芯片厂商写的代码, Camera Api2CameraManager.java -&gt; CameraService Camera2接口和Camera1接口差别很大。 CameraCharacteristics：描述摄像头的各种特性，我们可以通过CameraManager的getCameraCharacteristics(@NonNull String cameraId)方法来获取。 CameraDevice：描述系统摄像头，类似于早期的Camera。 CameraCaptureSession：Session类，当需要拍照、预览等功能时，需要先创建该类的实例，然后通过该实例里的方法进行控制（例如：拍照 capture()）。 CaptureRequest：描述了一次操作请求，拍照、预览等操作都需要先传入CaptureRequest参数，具体的参数控制也是通过CameraRequest的成员变量来设置。 Camera2直接通过binder连接CameraService，不像camera1还要经过jni。 ICameraService 是相机服务的接口。用于请求连接、添加监听等。 ICameraDeviceUser 是已打开的特定相机设备的接口。应用框架可通过它访问具体设备。 ICameraServiceListener 和 ICameraDeviceCallbacks 分别是从 CameraService 和 CameraDevice 到应用框架的回调 ICameraProvider 是CameraProvider的接口。 CameraProvider也是一个注册到ServiceManager的服务，它属于Camera HAL层服务的一部分。 Cameraservice通过 CameraProviderManager 来管理对 CameraProvider的操作。 CameraService-（持有）-&gt;CameraProviderManager-(Binder)-&gt;CameraProvider-（持有）-&gt;ICameraDeviceManager-&gt;ICameraDevice/ICameraDeviceSession CameraService可以通过CameraProvider获取ICameraDevice，CameraProver起到一个适配的功能，可以返回不同版本的Camera Device如Device HAL1,Device HAL3(在framework层，hal1和hal3的设备是分开枚举的，如device@1.0/device@3.2,但有可能最后调用的都是同一颗摄像头)。 源码位置：CameraManager.java:frameworks/base/core/java/android/hardware/camera2","link":"/2020/01/05/camera/android_camera_architecture_1/"},{"title":"Android实现USB功能裁剪和adb限制","text":"记录Android实现USB功能裁剪和adb限制的经验 USB功能剪裁首先我们要了解init.rc，init.rc会加载init.usb.rc和init.usb.configfs.rc，上层usb功能的选择会修改sys.usb.config，然后会触发init.usb.configfs.rc的选项。 以下截取了一部分init.usb.configfs.rc的代码，可以看到sys.usb.config这个属性的值会触发不同的usb模块功能。 123456789101112131415161718192021222324252627282930on property:sys.usb.ffs.ready=1 &amp;&amp; property:sys.usb.config=adb &amp;&amp; property:sys.usb.configfs=1 write /config/usb_gadget/g1/configs/b.1/strings/0x409/configuration \"adb\" symlink /config/usb_gadget/g1/functions/ffs.adb /config/usb_gadget/g1/configs/b.1/f1 write /config/usb_gadget/g1/UDC ${sys.usb.controller} setprop sys.usb.state ${sys.usb.config}on property:sys.usb.config=mtp &amp;&amp; property:sys.usb.configfs=1 write /config/usb_gadget/g1/configs/b.1/strings/0x409/configuration \"mtp\" symlink /config/usb_gadget/g1/functions/mtp.gs0 /config/usb_gadget/g1/configs/b.1/f1 write /config/usb_gadget/g1/UDC ${sys.usb.controller} setprop sys.usb.state ${sys.usb.config}on property:sys.usb.config=mtp,adb &amp;&amp; property:sys.usb.configfs=1 start adbdon property:sys.usb.ffs.ready=1 &amp;&amp; property:sys.usb.config=mtp,adb &amp;&amp; property:sys.usb.configfs=1 write /config/usb_gadget/g1/configs/b.1/strings/0x409/configuration \"mtp_adb\" symlink /config/usb_gadget/g1/functions/mtp.gs0 /config/usb_gadget/g1/configs/b.1/f1 symlink /config/usb_gadget/g1/functions/ffs.adb /config/usb_gadget/g1/configs/b.1/f2 write /config/usb_gadget/g1/UDC ${sys.usb.controller} setprop sys.usb.state ${sys.usb.config}on property:sys.usb.config=ptp &amp;&amp; property:sys.usb.configfs=1 write /config/usb_gadget/g1/configs/b.1/strings/0x409/configuration \"ptp\" symlink /config/usb_gadget/g1/functions/ptp.gs1 /config/usb_gadget/g1/configs/b.1/f1 write /config/usb_gadget/g1/UDC ${sys.usb.controller} setprop sys.usb.state ${sys.usb.config}on property:sys.usb.config=ptp,adb &amp;&amp; property:sys.usb.configfs=1 start adbd 所以我们要裁剪USB功能选择，很简单，修改这个init.usb.configfs.rc，去除一些可触发的选项。比如我的需求是只保留adb，去除所有mtp，ptp等usb功能。 那么我们新建一个文件system/core/rootdir/init.usb.configfs_limit.rc： 12345678910111213141516171819202122232425262728on property:sys.usb.config=none &amp;&amp; property:sys.usb.configfs=1 write /config/usb_gadget/g1/UDC \"none\" stop adbd setprop sys.usb.ffs.ready 0 setprop sys.usb.ffs.mtp.ready 0 write /config/usb_gadget/g1/bDeviceClass 0 write /config/usb_gadget/g1/bDeviceSubClass 0 write /config/usb_gadget/g1/bDeviceProtocol 0 rm /config/usb_gadget/g1/configs/b.1/f1 rm /config/usb_gadget/g1/configs/b.1/f2 rm /config/usb_gadget/g1/configs/b.1/f3 rmdir /config/usb_gadget/g1/functions/rndis.gs4 setprop sys.usb.state ${sys.usb.config}on property:init.svc.adbd=stopped setprop sys.usb.ffs.ready 0on property:sys.usb.config=adb &amp;&amp; property:sys.usb.configfs=1 start adbdon property:sys.usb.ffs.ready=1 &amp;&amp; property:sys.usb.config=adb &amp;&amp; property:sys.usb.configfs=1 write /config/usb_gadget/g1/configs/b.1/strings/0x409/configuration \"adb\" symlink /config/usb_gadget/g1/functions/ffs.adb /config/usb_gadget/g1/configs/b.1/f1 write /config/usb_gadget/g1/UDC ${sys.usb.controller} setprop sys.usb.state ${sys.usb.config}on property:sys.usb.config=mtp,adb &amp;&amp; property:sys.usb.configfs=1 start adbd 然后在项目mk文件里执行拷贝操作即可 12PRODUCT_COPY_FILES += \\ system/core/rootdir/init.usb.configfs_limit.rc:root/init.usb.configfs.rc adb限制客户有个需求，想要另外的开关来控制adb开启关闭，另外不想让原生的adb开关起效。 其实android上层控制adb开关，都是通过设置persist.sys.usb.config和sys.usb.config这两个属性值来控制的。如果这两个属性的值包含adb这个字段则会触发打开adb功能。 所以我们使用一个额外的属性persist.adb.enable来控制adb开关。然后我们直接修改frameworks/base/core/java/android/os/SystemProperties.java 123456789101112131415161718192021222324/** * Set the value for the given key. * @throws IllegalArgumentException if the value exceeds 92 characters */public static void set(String key, String val) { if (val != null &amp;&amp; val.length() &gt; PROP_VALUE_MAX) { throw newValueTooLargeException(key, val); } if(key.equals(USB_PERSISTENT_CONFIG_PROPERTY)||key.equals(USB_CONFIG_PROPERTY)) { if(containsFunction(val,\"adb\")&amp;&amp;getInt(\"persist.adb.enable\", 0)&gt;0){ val = \"adb\"; }else{ val = \"none\"; } } if (TRACK_KEY_ACCESS) onKeyAccess(key); native_set(key, val);} 这样就可以通过persist.adb.enable属性来控制adb的开启和关闭，而原生的adb开关则不会起作用。","link":"/2018/12/22/android_system/android_linux_loss_data_when_power_off/"},{"title":"Android如何屏蔽通话界面的视频彩铃","text":"当电话呼叫对方时，如果对方设置了视频彩铃，则会在呼叫页面出现运营商的视频和彩铃，可以通过修改系统应用中的Dialer App的incall页面来屏蔽。 比如MTK平台的Dialer App，路径如下：vendor/mediatek/proprietary/packages/apps/Dialer/java/com/android/incallui/call/DialerCall.java可以通过如下修改： 1234 public boolean isVideoCall() {- return getVideoTech().isTransmittingOrReceiving();+ return false;//getVideoTech().isTransmittingOrReceiving(); } 或者修改vendor/mediatek/proprietary/packages/apps/Dialer/java/com/android/incallui/InCallActivity.java 的private static ShouldShowUiResult getShouldShowVideoUi() 方法使其不显示视频页面","link":"/2018/11/06/android_java_framework/android_dialer_app_video_incall/"},{"title":"Camera相关基础总结","text":"总结下Camera相关的基础知识 相关名词解释1.Lens Shading 镜头暗影/暗角 镜头边沿的成像光线与镜头光轴有一个较大的夹角，沿着视场边缘光线的光圈减小，使得镜头边缘的光线是随着视角的变大成像亮度急剧地下降，呈现出画面角落的影像发暗。 2.Flare 耀斑 镜片的表面反射或镜筒、反光镜组的内面所引起的反射光，到达底面后造成画面整体或一部份产生了雾蒙，降低了图像的鲜锐度。 3.FOV 视场角 在摄影学中，视角(angle of view)是在一般环境中，相机可以接收影像的角度范围，也可以常被称为视野。一般说的广角/超广角就是形容的FOV。 4.Aperture 光圈 光圈，光通过的有效孔径，它的大小决定着通过镜头进入感光元件的光线的多少，一般光圈越大，成像越亮。 5.Shutter 曝光 指曝光时间的长短，一般通过快门去控制。 6.Focal Length 焦距 照相机中，镜头就相当于凸透镜，从镜片光学中心到CMOS成像平面的距离大概就等于焦距。 7.Defect Pixel 坏点 一般是指在sensor 制造过程中因为单个像素的电路异常而不能正常表现感光亮度。 8.Flicker 闪烁/闪频 在中国交流电频率是50Hz，光强的波动就是100Hz，周期10ms。如果camera曝光时间不是10ms的整数倍，那么在不同的感光面接收到的光能量一定不一样，体现在图像上就是有明暗条纹。 9.Moire 摩尔纹 摩尔纹是数码照相机等设备上的感光元件出现的高频干扰，会使图片出现彩色的高频率条纹。 消除摩尔纹，应当使镜头分辨率远小于感光元件的空间频率或者感光器件像素密度能够大大提高、远远超过镜头分辨率。 10.Purple Fringe 紫边 目前产生的原因有好几张说法。比较广为接受的就是镜头色散与颜色插值运算之问题导致的。 这个问题的发生在于拍摄高反差的景物时，在明暗交界的边缘部分会出现异常的紫色。 11.ISO 传统摄影用来衡量底片感光度的单位,数值越高,感光度越强,但Noise也越明显,ISO数值每增加一倍, 感光度也增加一倍。 12.Sharpness 锐度 是指影像的銳利度,影像中的高頻成分越多,影像就越銳利，主要由鏡頭決定,鏡頭品質好,成像越銳利,鏡頭品質差,成像越模糊。 13.Contrast 对比度 对比度,代表影像中亮(白)和暗(黑)的差异，所谓的高对比就是白的地方够亮,黑的地方够黑。 14.Saturation 饱和度 Saturation為HSV其中一個维度。HSV Color Domain的三个维度分别为– H: Hue , 色相 , 色彩在标准色环上的位置,以角度表示– S: Saturation , 饱和度 , 色彩的纯度, 以%表示. 0%(灰色), 100%(完全饱和)– V: Luminance, 明度 , 色彩的亮度, 以%表示.0%(黑色), 100%(白色) 15.DOF 景深 指在镜头前沿能够取得清晰图像的成像所测定的被摄物体前后距离范围。光圈、镜头焦距、及拍摄物的距离是影响景深的重要因素。 成像原理一般来说，camera 主要是由 lens 和 sensor IC 两部分组成。细分的来讲，camera 设备由下边几部分构成： 1.lens（镜头），收集被照物体反射光并将其聚焦于Sensor芯片上; 2.sensor（图像传感器），Sensor 将从 lens 上传导过来的光线转换为电信号， 再通过内部的 AD 转换为数字信号; 3.ISP（图像信号处理），主要完成数字图像的处理工作，处理 sensor 采集到的原始数据; 4.CAMIF（camera 控制器） 芯片上的 camera 接口电路，对设备进行控制，接收 sensor 采集的数据交给 CPU，并送入屏幕进行显示。 图像编码格式1.Bayer pattern：sensor获得彩色图像的方法是在 sensor表面覆盖含只含红、绿、蓝3色的马赛克滤镜，对其输出信号通过一定的处理算法实现彩色，所以这种感光器件的排列方式被称为bayer pattern。 因为只记录了单个的感光信息，通常也称为raw image。 2.RGB: 根据三基色原理，大部分光都可以用不同分量的R,G,B三色相加混合而成其中r，g，b分别为三基色参与混合的系数，调整三者的值可以混合出黑色光和白色光之间的各种各项颜色的光。 3.YUV: 现代彩色影像系统中，采用彩色的sensor 进行摄像。将摄得的彩色影像信号进行插值分色，分别放大校正后得到RGB，再经过矩阵变换电路得到亮度信号Y和两个色差信号R-Y(即U)，B-Y(即V)。这种色彩的表示方式就是YUV色彩空间。 图像处理1.AWB 自动白平衡 物体在不同的光源照射下，呈现的颜色是不同的，这是有光源的色温决定的。其中，白色物体变化最为明显。在同一色温环境中如果对一幅自色图像进行白平衡校正后.那么对于其他非白色图像就都能真实的再现物体的颜色。 2.AF 自动对焦 成像点不一定落在焦平面上面，通过前后调整镜头，使成像点落在焦平面上面, 这就是对焦的过程，保证画面清晰。AF不是所有camera模组都支持，得看有没有带AF的模组，定焦的模组就不带。 3.AE 自动曝光 由于环境的亮度是动态变化的，所以为了保证画面不会过亮/过暗，要及时调整曝光時間和ISO。自动曝光是相机根据光线的强弱自动调整曝光量，防止曝光过度或者曝光不足，它直接关系到画面的亮度和图像质量，是成像的基础。 4.Noise Reduction 去噪 5.Edge Enhancement 边缘加强 强化影像的Edge和Texture,让影像看起来更加锐利加强Edge,可能因为过强导致物体轮廓出现白边。加强Texture,会同步加强噪点的程度。 6.Color Reproduction 色彩还原 ISP会利用信号处理技术,来还原甚至加强原始影像的色彩.• 色域转换 : 为了方便色彩的处理, 将颜色由RGB转换到YCbCr或是H.S.V• 色调转换 : 改变色彩的属性, ex. 红 -&gt; 橙 -&gt; 黄• 饱和度转换 : 让色彩变的更鲜艳或是较不鲜艳","link":"/2018/12/01/camera/camera_basic/"},{"title":"Camera硬件知识记录","text":"记录下Camera相关的硬件知识 1，Image Sensor类型a) YUV Sensor YUV Sensor输出的Data格式为YUV，图像的效果处理使用Sensor内部的ISP，BB端接收YUV格式的data后只进行格式的转换，效果方面不进行处理，由于Sensor内部的ISP处理能力有限，且YUV Sensor的数据量比较大（YUV422的格式1个pixel2个byte），一般Size都比较小，常见的YUV sensor都是5M以下 b) Raw Sensor Raw Sensor输出的Data格式为Raw，图像的效果处理使用BB端的ISP，BB端接收Raw data后进行一系列的图像处理（OB，Shading，AWB，Gamma，EE，ANR等），效果方面由BB端控制，需要针对不同的模组进行效果调试，Raw sensor是目前的主流，数据量比YUV Sensor小（RAW10 格式的sensor 1个pixel 10个bit）使用平台ISP处理，能支持较大的size 2，硬件接口简单说来，Camera的接口分为并行和串行两种方式，而目前我们平台主要支持的串行方式为mipi接口，Parallel接口和mipi接口的介绍可以参考下图 3，常见基本概念a) 三路电压 camera包含的三路电压为模拟电压（VCAMA），数字电压（VCAMD），IO口电压（VCAMIO） b) I2C信号 BB与Sensor端通过I2C来通信（读写寄存器），包括SCL（I2C Clock） SDA（I2C Data）信号 c) mipi几条lane mipi data是成对的差分信号，MIPI_RDN和MIPI_RDP，有几对这样的pin脚，则说明是几条lane，同一颗sensor由于register setting不同，输出的信号有可能是2 lane或者4lane等 d) parallel高低八位 Parallel接口一般Data有10根pin，分别叫做Data0Data9，Parallel sensor输出的data信号是8根pin时，这八根pin接到的是Data0Data7还是Data2~Data9，需要配置正确，叫做接到高八位或者低八位，接错了可能产生如下现象 e) Data Format Sensor输出的数据格式，对于YUV Sensor来说，Data Fomat一般有YUYV，YVYU，UYVY等，配置不对可能会导致颜色和亮度错掉，例如下图 对于Raw Sensor来说，Data Format就是First Pixel的颜色，分为R，Gr，Gb，B，配置不对会导致颜色错误 f) MCLK BB提供给Sensor的外部clock g) PCLK Parallel接口的Sensor输出的clock，该clock变化一次，data更新一次 h) mipi 信号 mipi信号包括mipi clock和mipi data，该信号是高速信号，用来传输mipi数据包 4，电子快门机械快门可以理解为一道真的“门”，打开光线进来，关闭停止接受光线，“打开——关闭”就是曝光时间。电子快门没有物理上的门，而是利用了Sensor感光系统不通电不工作的原理，在Sensor不通电的情况下，尽管像场窗口仍然“大敞开”，但是并不能产生图像。如果在按下快门钮时，使用电子时间电路，使Sensor只工作“一个指定的时间长短”，就也能获得像有快门“瞬间打开”一样的效果。 a) 机械快门曝光时间：【打开——接收光线——关闭】之间的间隔。 b) 电子快门曝光时间：【将像素清零——接收光线——读取该像素】之间的间隔。 电子快门分两类：Rolling Shutter与Global Shutter a) Rolling Shutter，即卷帘快门。 这种快门的特点是，捕捉到的一幅图像中，各部分不是同一刻的。为什么？假设拍一个人，从头部开始拉开帘子，即曝光第一行，是当前时刻T。帘子慢慢拉下，当完全拉开到脚部时，已经到了时刻T+t。用通常的1秒30帧的速度来考虑，头和脚的时间差距有33ms左右。 对任一像素，在曝光开始时现将其清零，然后等待曝光时间过后，将信号值读出。因为数据的读出是串行的，所以清零/曝光/读出也只能逐行顺序。 所以曝光时间等于line*number of line（line指的是重置（或者读取）的行数，number of line是指重置——读取间隔内，经过的行数）。 b) Global Shutter，即全局快门。 全局快门没有拉帘子的过程，而是走到帘子前一把扯掉，全部曝光，然后再同时停止曝光。这样就保证了一帧图像中，各部分内容发生于同一时刻。","link":"/2018/12/03/camera/camera_basic_hardware/"},{"title":"Camera Sensor驱动修改经验","text":"点亮摄像头必须移植配置好Camera的驱动（Sensor/AF/OTP），其中Camera Sensor驱动是其中重点。Camera模组是否上电成功？I2C通信是否正常？能否读取到硬件ID？硬件ID是否匹配？寄存器设置是否正确？Fps计算是否正确？等等问题都会影响Camera是否正常工作。 记录下修改Camera Sensor Driver代码的经验，由于各平台架构不同，尽量忽略平台差异，只谈流程/参数的含义和经验。 Sensor Driver的工作Sensor驱动代码一般不用自己写，Camera Sensor厂商会提供你需要的平台或已在别的类似平台上已经实现好的Sensor驱动代码和文档，你必须按文档里的DataSheet配置参数才能使Camera正常工作。 当你在平台上配置好（前后置）Camera Sensor的类型时，平台的代码会自动匹配到对应的驱动上。 BB端和Camera的通信一般都是I2C通信（读写Camera的寄存器）。 当Camera物理连接正常时，会先走power on上电流程，上电成功后会读取硬件id（通过I2C读取寄存器固定某个位置的值，下面会提到），匹配成功后进行初始化，写入代码里的寄存器初始化表，初始化fps计算帧率，这一步后Camera就能正常出图，随后就可以使用接口对Camera进行操作（还是I2C读写寄存器的方式），使用结束后对Camera进行下电。 上下电时序查看硬件文档的上电时序是怎么样的，然后按照文档里的编写上电函数。上电主要对三路电压（camera包含的三路电压为模拟电压（VCAMA），数字电压（VCAMD），IO口电压（VCAMIO））、Reset脚、PDN脚、Mlck脚进行控制。 上电举个例子 1234567891011121314151617181920212223242526272829303132333435if (power_on) { //.reset_pulse_level = SENSOR_LOW_PULSE_RESET, //.power_down_level = SENSOR_LOW_LEVEL_PWDN, //PDN脚拉低 hw_sensor_power_down(sns_drv_cxt-&gt;hw_handle, power_down); //Reset脚拉低 hw_sensor_set_reset_level(sns_drv_cxt-&gt;hw_handle, reset_level); //disable MCLK hw_sensor_set_mclk(sns_drv_cxt-&gt;hw_handle, SENSOR_DISABLE_MCLK); //关闭三路电压 hw_sensor_set_avdd_val(sns_drv_cxt-&gt;hw_handle, SENSOR_AVDD_CLOSED); hw_sensor_set_dvdd_val(sns_drv_cxt-&gt;hw_handle, SENSOR_AVDD_CLOSED); hw_sensor_set_iovdd_val(sns_drv_cxt-&gt;hw_handle, SENSOR_AVDD_CLOSED); usleep(1 * 1000); //设置三路电压 //.avdd_val = SENSOR_AVDD_2800MV, // .iovdd_val = SENSOR_AVDD_1800MV, // .dvdd_val = SENSOR_AVDD_1500MV, hw_sensor_set_iovdd_val(sns_drv_cxt-&gt;hw_handle, iovdd_val); usleep(1 * 1000); hw_sensor_set_dvdd_val(sns_drv_cxt-&gt;hw_handle, dvdd_val); usleep(1 * 1000); hw_sensor_set_avdd_val(sns_drv_cxt-&gt;hw_handle, avdd_val); usleep(1 * 1000); //设置MCLK hw_sensor_set_mclk(sns_drv_cxt-&gt;hw_handle, EX_MCLK); usleep(10 * 1000); //拉高PDN脚 hw_sensor_power_down(sns_drv_cxt-&gt;hw_handle, !power_down); //拉高reset脚 hw_sensor_set_reset_level(sns_drv_cxt-&gt;hw_handle, !reset_level); } 如果Sensor代码里没有配置下电时序，那么下电时序就是把上电时序倒过来执行一遍。 当Read ID失败的时候怎么排查1.检查硬件连接 除了看线的连接外，要看金手指接触有没有不良的情况。 2.检查上电是否成功 看log,上电函数是否执行完成了，用万用表量对应的pin脚（三路电压/reset/pdn）状态，是否跟上电函数里设置的一样。 3.检查I2C通路是否正常 用示波器连接I2C的SDA和SCL脚，查看波形是否正常 4.检查I2C从设备地址 5.检查I2C的读写函数 Read ID正常，初始化失败了怎么办查看log,看看fps的计算结果是否正常，检查是不是fps帧率计算有问题，一般 fps = 1000000000.0 / (frame length * line_time);要注意1000000000.0 和 line_time 的单位，可能是微秒或纳秒。一般fps的范围都在15-60之间。 参数解析Sensor Driver代码里有很多参数，下面解析一下参数的含义和用法。 p.s.参数的值要以硬件datasheet为准。 1.I2C_SLAVE_ADDR I2C从设备地址，硬件文档datasheet有写明，有两个地址，分别为读地址和写地址，有8位，比如 1#define I2C_SLAVE_ADDR 0x6c /* 8bit slave address*/ 一般会右移一位，最后一位添加0为读地址，1为写地址 1234sensor_module_info s_c2590_module_info_tab[VENDOR_NUM] = { ... .major_i2c_addr = I2C_SLAVE_ADDR &gt;&gt; 1, ... 2.硬件ID的值和在寄存器里高低位位置 1234#define XXXX_PID_ADDR 0x0000#define XXXX_PID_VALUE 0x02#define XXXX_VER_ADDR 0x0001#define XXXX_VER_VALUE 0x02 驱动初始化里需要先检查硬件ID，就是通过读取寄存器上面两个ADDR的值，比较两个VALUE是否一致，id一致则代表连接的硬件是我们驱动对应的硬件。 3.图像尺寸 123456789101112131415/* effective sensor output image size */#define PREVIEW_WIDTH 1600#define PREVIEW_HEIGHT 1200#define SNAPSHOT_WIDTH 1600#define SNAPSHOT_HEIGHT 1200/*Raw Trim parameters*/#define PREVIEW_TRIM_X 0#define PREVIEW_TRIM_Y 0#define PREVIEW_TRIM_W 1600#define PREVIEW_TRIM_H 1200#define SNAPSHOT_TRIM_X 0#define SNAPSHOT_TRIM_Y 0#define SNAPSHOT_TRIM_W 1600#define SNAPSHOT_TRIM_H 1200 4.line time和frame length 1234567/*line time unit: 1ns*/#define PREVIEW_LINE_TIME 54457#define SNAPSHOT_LINE_TIME 54457/* frame length*/#define PREVIEW_FRAME_LENGTH 1224#define SNAPSHOT_FRAME_LENGTH 1224 line time跟电子快门的曝光有关，是一行的曝光时间，frame length代表有多少行，一般大于图像的HEIGHT。 5.EX_MCLK 提供给Sensor的外部clock，一般不变。 12/* please don't change it */#define EX_MCLK 24 6.LANE_NUM mipi data是成对的差分信号，MIPI_RDN和MIPI_RDP，有几对这样的pin脚，则说明是几条lane，同一颗sensor由于register setting不同，输出的信号有可能是2 lane或者4lane等 123/*Mipi output*/#define LANE_NUM 1#define RAW_BITS 10 举例：MT6735，5M摄像头，有效像素为2592*1944，30fps帧率，10位ADC色彩深度，最少几lane (1) 从平台资料可知，MIPI CSI速率最高为1.5Gbps (2) 2592 * 1944 * 10 * 30 * (1+20%) = 1.8Gbps lane = 1.8 / 1.5 &gt; 1，所以最少需要 2 lane 6.MIPI_PER_LANE_BPS 一个MIPI接口每秒传输速率，单位比特每秒 12#define PREVIEW_MIPI_PER_LANE_BPS 534 /* 2*Mipi clk */#define SNAPSHOT_MIPI_PER_LANE_BPS 534 /* 2*Mipi clk */ 还有其他参数，比如镜像旋转，即上下镜像左右镜像，通过设置寄存器就可以做到。但是如果相差90度，那就是模组或放置方向差了90度，要修改硬件。","link":"/2019/10/22/camera/camera_sensor_drive_experience/"},{"title":"JAVA根证书验证用户证书是否可信和解密数据","text":"一般用户证书和加密数据是一起发放到客户端的，但是使用用户证书的公钥解密数据前需要验证用户证书是否可信，即从源头来说是否由根证书签发的，按证书链去认证。使用根证书验证用户证书可信并解密的Java实现如下： 1.读取根证书文件初始化根证书对象，并获取根证书中的公钥 123CertificateFactory certificateFactory = CertificateFactory.getInstance(\"X.509\");Certificate rootCert = certificateFactory.generateCertificate(new FileInputStream(rootCertPath));PublicKey rootCertPublicKey = rootCert.getPublicKey(); 2.使用用户证书byte数组数据初始化用户证书对象 12X509Certificate userCert = (X509Certificate)certificateFactory.generateCertificate( new ByteArrayInputStream(userCertByteArray)); 3.使用用户证书验证根证书的公钥，如果验证通过（即不抛出Exception）说明这个用户证书是这个根证书签发的,同时检查用户证书是否有效 12345678try { userCert.verify(rootCertPublicKey); userCert.checkValidity(); Log.d(TAG,\"------------- 工作证书验证成功 -----------\");}catch (Exception e) { Log.d(TAG,\"------------- 工作证书验证失败 -----------\"); } 4.最后使用用户证书的公钥进行解密 1234567891011121314151617try { Cipher cipher = Cipher.getInstance(\"RSA/ECB/NoPadding\"); cipher.init(Cipher.DECRYPT_MODE, userCert); byte[] output = cipher.doFinal(cipherData); return output;} catch (NoSuchAlgorithmException e) { throw new Exception(\"无此解密算法\");} catch (NoSuchPaddingException e) { e.printStackTrace(); return null;} catch (InvalidKeyException e) { throw new Exception(\"解密公钥非法,请检查\");} catch (IllegalBlockSizeException e) { throw new Exception(\"密文长度非法\");} catch (BadPaddingException e) { throw new Exception(\"密文数据已损坏\");}","link":"/2019/03/21/java/java_certificate_verify_and_decript/"},{"title":"Linux cgroups机制 cpu/cpuset/schedtune","text":"Linux cgroups机制中的cpu/cpuset/schedtune子系统 跟linux/android进程调度策略有关，记录下各项功能参数的用法。 Cpu cpu.shares：整数值，用来设置分组任务获得 CPU 时间的相对值。 cpu.rt_runtime_us：用来设置实时进程获得 CPU 资源的周期，单位为微妙。 cpu.rt_period_us：用来设置实时进程可以最长获得 CPU 资源的时间，单位为微秒 在每个指定的周期,允许一个实时任务组最多执行多长时间。当实时任务组在一个周期用完了带宽时,这个任务组将会被节流,不允许继续运行,直到下一个周期。比如cpu.rt_period_us为1000000，cpu.rt_runtime_us为950000，代表不同策略组的Cpu.shares 比例，决定不同策略组获得cpu时间片的比例A group 的 cpu.shares 文件不变, 值为 1024B group 的 cpu.shares 文件中的值改为 512, 这样, 相当于B占用CPU总资源的 1/3 (因为 512 / (512+1024) = 1/3) CpusetCpuset用于修改task的cpu核亲和度 cpus对应内核亲和度，必须是连续的，比如0-3,2-6 cpu_exclusive对应是否核独占，如果设置代表tasks将独占cpus对应的cpu核，一般都是关闭 Schedtuneschedtune提供了一套用户接口的工具，用于功耗-性能调节。schedtune是cgroup的一个子系统。所以在cgroup的mount节点下，stune分别为每个group，都提供了2个调节开关： schedtune.boostboost的值用int型表示，范围为[0, 100]。boost默认值为0，代表CFS调度器会工作在能耗最低的状态。这也意味着schedutil使task跑在最低的OPP。boost值100，则表示调度器为工作在性能最高的状态，同时OPP也处在最大。0-100的范围可以根据其他场景来进行适当调节。比如，优化交互的响应、电池电量变化等。 schedtune.prefer_idle这是一个控制调度器节省功耗优先，还是性能优先的flag。默认值0，会让CFS调度器根据energy-aware wakeup策略来分配在group中的task。（功耗优先）当值设为1，会让CFS调度器分配task时，有最小的wakeup延迟。（性能优先）android平台下使用这个flag用来表示正在和用户交互的应用。设为1的节点：dev/stune/foreground/schedtune.prefer_idledev/stune/top-app/schedtune.prefer_idle设为0节点：dev/stune/background/schedtune.prefer_idledev/stune/rt/schedtune.prefer_idle","link":"/2020/06/10/linux_system/linux_cgroup/"},{"title":"Linux文件系统和个人理解","text":"记录Linux文件系统基础和个人理解 关键概念1.inode 和 block 文件是存储在硬盘上的，硬盘的最小存储单位叫做扇区sector，每个扇区存储512字节。操作系统读取硬盘的时候，不会一个个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个块block。这种由多个扇区组成的块，是文件存取的最小单位。块的大小，最常见的是4KB，即连续八个sector组成一个block。 文件数据存储在块中，那么还必须找到一个地方存储文件的元信息，比如文件的创建者、文件的创建日期、文件的大小等等。这种存储文件元信息的区域就叫做inode，中文译名为索引节点，也叫i节点。因此，一个文件必须占用一个inode，但至少占用一个block。 元信息 → inode 数据 → block 2.页缓存 linux中页缓存的本质就是对于磁盘中的部分数据在内存中保留一定的副本，使得应用程序能够快速的读取到磁盘中相应的数据，并实现不同进程之间的数据共享。 3.页表 进程访问虚拟内存，CPU执行时通过分页机制转换成物理内存访问，虚拟地址到物理内存的转换表称为页表，这个转换是个查表的过程。 同一程序运行起来的两个进程，虚拟地址空间相同，但对应的物理空间是不一定相同的。OS需要给每个进程设置一份页表，在进程调度过程中，上下文切换阶段会做页表的切换。 4.file结构体 struct file结构体定义在include/linux/fs.h中定义。文件结构体代表一个打开的文件，系统中的每个打开的文件在内核空间都有一个关联的 struct file。它由内核在打开文件时创建，并传递给在文件上进行操作的任何函数。在文件的所有实例都关闭后，内核释放这个数据结构。 5.mmap mmap是一种内存映射文件的方法，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用read,write等系统调用函数。 文件读写过程1.进程调用库函数read()向内核发起读文件的请求；2.内核通过检查进程的文件描述符定位到虚拟文件系统已经打开的文件列表项，调用该文件系统对VFS的read()调用提供的接口；3.通过文件表项链接到目录项模块，根据传入的文件路径在目录项中检索，找到该文件的inode；4.inode中，通过文件内容偏移量计算出要读取的页；5.通过该inode的i_mapping指针找到对应的address_space页缓存树—基数树，查找对应的页缓存节点；（1）如果页缓存节点命中，那么直接返回文件内容；（2）如果页缓存缺失，那么产生一个缺页异常，首先创建一个新的空的物理页框，通过该inode找到文件中该页的磁盘地址，读取相应的页填充该页缓存（DMA的方式将数据读取到页缓存），更新页表项；重新进行第5步的查找页缓存的过程； 个人理解1.mmap和普通io的速度对比 mmap相比，read和write执行了更多的系统调用，并做了更多的复制。read和write将数据从内核缓冲区中复制到应用缓冲区，然后再把数据从应用缓冲区复制到内核缓冲区。而mmap则直接把数据从映射到地址空间的一个内核缓冲区复制到另一个内核缓冲区。当引用尚不存在的内存页时，这样的复制过程就会作为处理页错误的结果而出现（每次错页读发生一次错误，每次错页写发生一次错误）。 所以他们两者的效率的比较就是系统调用和额外的复制操作的开销和页错误的开销之间的比较，哪一个开销少就是哪一个表现更好。 2.突然断电的情况怎么保证写入成功 普通io的写入不一定会成功，要看脏数据有没有回写后备存储。系统只有适当时机(内存低于一定阈值或者超过一定时长)才会把页缓存的写到后备存储。显式的调用fsync、fdatasync或者sync的时候，内核按照要求执行回写操作。 3.fd文件描述符怎么跨进程传递 由于每个进程的文件描述符列表都不一样，对应的是已打开文件列表的序号，A进程的fd传到B进程是没法使用的，一种办法是，通过内核调用，通过A进程的fd找到对应的inode，然后为B进程试生成一个新的fd，可以参考binder的实现，因为binder持有所有调用进程的task_struct，binder就为fd传递实现了这些操作。","link":"/2020/04/11/linux_system/linux_filesystem/"},{"title":"Android/Linux异常断电情况下数据丢失情况分析解决","text":"记录一次系统断电时导致数据丢失问题解决 系统突然断电，有可能会导致断电前保存的数据丢失，比如刚保存的屏幕解锁图案断电后重启就丢失了。 要解决这个问题首先要了解linux文件系统原理: 1、进程发起读文件请求。 2、内核通过查找进程文件符表，定位到内核已打开文件集上的文件信息，从而找到此文件的inode。 3、inode在address_space上查找要请求的文件页是否已经缓存在页缓存中。如果存在，则直接返回这片文件页的内容。 4、如果不存在，则通过inode定位到文件磁盘地址，将数据从磁盘复制到页缓存。之后再次发起读页面过程，进而将页缓存中的数据发给用户进程。 总结来说，常规文件操作为了提高读写效率和保护磁盘，使用了页缓存机制。这样造成读文件时需要先将文件页从磁盘拷贝到页缓存中，由于页缓存处在内核空间，不能被用户进程直接寻址，所以还需要将页缓存中数据页再次拷贝到内存对应的用户空间中。这样，通过了两次数据拷贝过程，才能完成进程对文件内容的获取任务。写操作也是一样，待写入的buffer在内核空间不能直接访问，必须要先拷贝至内核空间对应的主存，再写回磁盘中（延迟写回），也是需要两次数据拷贝。 解决办法: 在Linux系统中，在写入文件过程中一般先放到页缓存中，等到适当的时候再写入磁盘以提高系统的运行效率。sync命令则可用来强制将内存缓冲区中的数据立即写入磁盘中.Runtime runtime = Runtime.getRuntime();Process proc = runtime.exec(“sync”);所以一旦写入文件操作完成后,立即代码执行sync指令,即可避免文件写入最后没有保存到硬件的情况.","link":"/2020/01/20/linux_system/linux_filesystem_offpower_bug/"},{"title":"Linux管道使用经验","text":"Linux管道使用注意事项和经验 如何保证写入原子性一个管道的容量是有限的。POSIX规定，少于 PIPE_BUF的写操作必须原子完成：要写的数据应被连续的写到管道；大于 PIPE_BUF 的写操作可能是非原子的: 内核可能会把此数据与其它进程的对此管道的写操作交替起来。POSIX规定PIPE_BUF至少为512B(linux中为4096B)，具体的语义如下: 其中n为要写的字节数 n &lt;= PIPE_BUF, O_NONBLOCK无效：原子的写入n个字节。如果管道当前的剩余空间不足以立即写入n个字节，就阻塞直到有足够的空间。 n &lt;= PIPE_BUF, O_NONBLOCK有效：写入具有原子性，如果有足够的空间写入n个字节，write立即成功返回。否则一个都不写入，返回错误，并设置errno为EAGAIN。 n &gt; PIPE_BUF, O_NONBLOCK无效：非原子写。可能会和其它的写进程交替写。write阻塞直到将n个字节写入管道。 n &gt; PIPE_BUF, O_NONBLOCK有效：如果管道满，则write失败，返回错误，并将errno设置为 EAGIN。如果不满，则返回写入的字节数为1~n，即部分写入，写入时可能有其他进程穿插写入。 结论：1、当要写入的数据量不大于PIPE_BUF时，linux将保证写入的原子性。2、当要写入的数据量大于PIPE_BUF时，linux将不再保证写入的原子性 PIPE_BUF 缓冲区 4096字节PIPE 总容量 65536字节 = PIPE_BUF * 16 这些都是Linux硬编码定义的 成功创建命名管道文件的前提1.文件所在目录不能是FAT32，FAT32不支持mknod（mkfifo会调用mknod）2.要有目录的文件读写权限3.如果系统开启selinux，要保证有selinux权限 管道文件注意事项1.如果所有读取端描述符都已关闭，此时进程再次往管道里面写入数据，写操作会失败，errno被设置为EPIPE，同时内核会向写入进程发送一个SIGPIPE的信号2.当所有的读取端和写入端都关闭后，管道才能被销毁3.只有当所有的写入端描述符都已关闭，且管道中的数据都被读出，对读取端描述符调用read函数才会返回0（即读到EOF标志）3、若管道文件没有被以写的方式打开，则以只读打开会阻塞4、若管道文件没有被以读的方式打开，则以只写打开会阻塞","link":"/2020/01/07/linux_system/linux_pipe_use_experience/"},{"title":"使用OpenCV对二维码/条形码进行矫正","text":"OpenCV提供了很多图像处理的API，我们可以利用这些API做一些矫正四边形物体比如二维码/条码的工作。 大概过程如下： resize（图像尺寸缩小）-&gt;threshold（二值化）-&gt;erode（几次膨胀腐蚀）-&gt;HoughLines（寻找直线）-&gt;筛除出二维码/一维码的边线，计算出边线的倾斜角度-&gt;warpAffine（对原图像进行仿射变换） 下面贴具体的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104void correctImage(unsigned char *nv21, int width, int height, unsigned char *dest) { int resizeWidth = width/2; int resizeHeight = height/2; //初始化需要使用的Mat Mat imgMat(height * 3 / 2, width, CV_8UC1, nv21); //灰度图Mat Mat grayMat(height, width, CV_8UC1); //最终结果的Mat Mat resultMat(height, width, CV_8UC1,dest); //过程Mat Mat innerMat(resizeHeight, resizeWidth, CV_8UC1); Mat binMat(resizeHeight, resizeWidth, CV_8UC1); //将yuv420sp转为灰度图 cvtColor(imgMat, grayMat, CV_YUV420sp2GRAY); //缩小图像尺寸以减少后面图像处理工作的耗时 resize(grayMat, innerMat, Size(resizeWidth, resizeHeight)); //自适应二值化参数 int blockSize = 3; int constValue = 5; const int maxVal = 255; //自适应二值化 adaptiveThreshold(innerMat, binMat, maxVal,ADAPTIVE_THRESH_GAUSSIAN_C, THRESH_BINARY, blockSize, constValue); int rectWidth = resizeWidth / 5; int rectHeight = resizeHeight / 5; int centerX = resizeWidth / 2, centerY = resizeHeight / 2; Mat element = getStructuringElement(2, Size(7, 7)); //膨胀腐蚀 for (int i = 0; i &lt; 2; i++) { erode(innerMat, innerMat, element); i++; } erode(innerMat, binMat, element); binMat = innerMat - binMat; //寻找直线 vector&lt;Vec2f&gt; lines; HoughLines(binMat, lines, 1, CV_PI / 150, 90, 0, 0); LOGV(\"OpenCV_CorrectImage寻找边线，边线数量:%d\", lines.size()); //由于边线可能有很多，这里最多取8条边线来计算角度 int lineNum = lines.size() &gt; 8 ? 8 : lines.size(); float sum = 0; //num参数记录倾斜的线条的数量 int num = 0; for (int i = 0; i &lt; lineNum; i++) { float theta = lines[i][1]; //各个角度对应的theta值,相当于:角度/180*PI //90-&gt;1.5708 //100 -&gt; 1.7453 //80 -&gt; 1.3963 //95-&gt;1.6580 //85-&gt;1.4835 //0 -&gt;0 //5-&gt;0.0872 //10 -&gt; 0.1745 //12 -&gt;0.209 //15 -&gt;0.2618 //180-&gt; 3.1415 //170 -&gt;2.967 // 过滤掉角度正常的，0-15度，80-100 ,170-180 if ((theta &gt;= 0 &amp;&amp; theta &lt;= 0.2618) || (theta &gt;= 1.3963 &amp;&amp; theta &lt;= 1.7453) || (theta &gt;= 2.967 &amp;&amp; theta &lt;= 3.1416)) { } else { if (theta &gt;= 1.5708) theta = theta - 1.5708; LOGV(\"OpenCV_CorrectImage寻找边线，角度:%f\", theta); sum += theta; num += 1; } } //需要矫正 if (num &gt; 0) { float average = sum / num; //转成角度 double angle = average / CV_PI * 180; LOGV(\"OpenCV_CorrectImage寻找边线，角度:%f\", angle); //如果矫正角度大于5才矫正 if (angle &gt; 5) { Point2f center; center.x = float(width / 2.0); center.y = float(height / 2.0); Mat M = getRotationMatrix2D(center, angle, 1); //仿射变换，背景色填充为黑色 warpAffine(grayMat, resultMat, M, resultMat.size(), 1, 0, Scalar(255)); LOGV(\"OpenCV_CorrectImage角度变换完成\"); } }} OpenCV很多图像处理的API有各种各样的参数，不同的参数会适合不同的场景，所以以上代码也不可能适应所有场景下的二维码/条码图片。","link":"/2018/12/19/opencv/opencv_correct_image/"},{"title":"记录下使用OpenGL的经验","text":"此篇文章记录下自己在android平台上使用opengl的经验，顺便记录下自己开源项目使用opengl的思路，内容会很零碎，因为只是随便整理记录下。 opengl如果要避免添加滤镜后帧数减少，要使用FBO。比如camera每秒返回30帧的数据，如果我们的opengl绘制不能在33毫秒内完成，则会导致最后显示的帧率改变，假如 GPU 遇到性能瓶颈，导致无法在一帧内更新渲染结果到帧缓存区，那么从缓存区读到的会是上一帧的内容，导致帧率降低界面卡顿。 FBO即为opengl离屏渲染的一种方式，指的是GPU在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作. FBO的id为0时则代表是当前屏幕的。 比如滤镜的实现：1.创建一个FBO1和FBO1对应的纹理，将纹理绑定到FBO12.绑定到FBO1，进行滤镜处理，渲染则会渲染到FBO绑定的纹理上3.绑定到FBO0，再渲染到屏幕 opengl里的program 是可以复用的 但是shader一旦绑定是不能被其他program使用的，一个program绑定一个顶点shader和一个片段shader opengl的图元只有点、线、三角形，所以要绘制其他形状只能用三角形叠加，比如圆角就是多个三角形叠加成半圆。 opengl滤镜制作 滤镜实际就是对图像的像素点色彩值进行多次加工，代码实现上就是自定义shader进行色彩处理 例如亮度，就是r,g,b分别加上亮度r+0.1 ,g+0.1,b+0.1hsv是把rgb转hsv，再叠加 另外可以使用混合模式，减少渲染次数 https://cloud.tencent.com/developer/article/1132385 “终端图像处理系列 - OpenGL混合模式的使用” https://blog.csdn.net/junzia/article/details/76580379 “Android OpenGLES2.0（十八）——轻松搞定Blend颜色混合” 自己的开源项目BubbleTextureview实现思路 具体是自定义绘制了一个气泡状的模型GLbubbleGeometry，另外基于GLTextureView，将TextureView的图像数据当纹理显示。 GLtextureView 是模仿根据Glsurfaceview 改过来的，新建了一个Glthread 去链接EGL, 相关知识搜索OPENGL GLtextureView相关文章。 float[] vertices = new float[verticesSize]; 保存了所有顶点，不重复short[] indices = new short[indicesSize]; 保存了三角形绘制的点顺序具体就是0，1，2，3，2，3，4，3，4，5 .。。。 这样，绘制根据这个点顺序去绘制 topleftradius 是0-1的百分比圆角半径长度，适应opengl的0-1坐标系 求圆角的多个三角形点坐标时用vertices[currentOffset + 5] = center[0] + radius[0] * (float) Math.cos(rads);x坐标为 中心点 + 半径*cos角度 vertices[currentOffset + 6] = center[1] + radius[1] * (float) Math.sin(rads);y坐标为 中心点 + 半径*sin角度 π就是逆时针180°，-π就是顺时针180° MediaCodec 要将surface里的数据转为混合为mp4,必须要4.3以上的手机，因为EGLExt.eglPresentationTimeANDROID(mEGLDisplay, mEGLSurface, nsecs); 这个设置surface时间的方法是必须api18的. 如果不用MediaMuxer混合视频，可以用mp4parser这个开源库，就能在4.1的手机上转码视频为mp4","link":"/2018/05/19/opengl/opengl_experience/"},{"title":"Android UVCCamera/libuvc遇到的卡死崩溃bug和解决方法","text":"分享下debug uvccamera/libuvc这些so库遇到的卡死崩溃问题和思路 1.UVCCamera执行stopPreview或release时阻塞卡死在多次重复打开关闭uvc摄像头的时候，上层调用stopPreview/release会概率性卡死，经过调试一步步定位调用函数和阻塞住的位置 android java层调用略，下面直接从so库的代码开始； –&gt;UVCCamera/UVCCamera.cpp-stopPreview() –&gt;UVCCamera/UVCPreView.cpp-stopPreview()这里设置mIsRunning = false;停止预览帧处理；调试发现，在下面这一句代码阻塞住没有往下走了：pthread_join(preview_thread, NULL) != EXIT_SUCCESS;pthread_join会阻塞到preview_thread预览线程执行结束为止，所以预览处理没有正常结束；–&gt;UVCCamera/UVCPreview.cpp-do_preview()结束预览时会停止libuvc的流处理uvc_stop_streaming(mDeviceHandle);，所以流处理没有正常结束；–&gt;libuvc/stream.c-uvc_stop_streaming()–&gt;libuvc/stream.c-uvc_stream_close()–&gt;libuvc/stream.c-uvc_stream_stop()这一步停止流的传输，并将所有流转换器都释放掉：strmh-&gt;running = 0;并遍历调用libusb_cancel_transfer(strmh-&gt;transfers[i]);至于关键的阻塞代码如下： 12345678910/* Wait for transfers to complete/cancel */ for (; 1 ;) { for (i = 0; i &lt; LIBUVC_NUM_TRANSFER_BUFS; i++) { if (strmh-&gt;transfers[i] != NULL) break; } if (i == LIBUVC_NUM_TRANSFER_BUFS) break; pthread_cond_wait(&amp;strmh-&gt;cb_cond, &amp;strmh-&gt;cb_mutex); } 这里会一直循环等待所有流转换器都释放置空完成，而问题就在于偏偏有个别流转换器就是无法正常释放。 为什么没有正常释放完成，是因为libusb_cancel_transfer失败返回LIBUSB_ERROR_NOT_FOUND的状态时，转换器持有无效的buffer和指针，导致上面的循环代码一直不往下走。 一般释放正常时的Log如下： 1234[4632*stream.c:989:_uvc_stream_callback]:not retrying transfer, status = 3[4632*stream.c:629:_uvc_delete_transfer]:begin[4632*stream.c:642:_uvc_delete_transfer]:Freeing transfer 5 (0x72fdbe5960)[4632*stream.c:656:_uvc_delete_transfer]:end 但函数阻塞住时，我发现并没有看到index为6的transfer执行delete的Log，于是我怀疑是否跟transfer的数量有关。 这时查看源码里有一个transfer buffers的数量定义如下： 12345678910libuvc/libuvc_internal.h/* set a high number of transfer buffers. This uses a lot of ram, but avoids problems with scheduling delays on slow boards causing missed transfers. A better approach may be to make the transfer thread FIFO scheduled (if we have root). We could/should change this to allow reduce it to, say, 5 by default and then allow the user to change the number of buffers as required. */#define LIBUVC_NUM_TRANSFER_BUFS 10 如果设置得太高，不仅会提高内存的占用，在处理速度慢的板子上也会有transfer浪费掉。这里我尝试降低数量值为5，再次调试开关100次，stopPreview卡死的问题不再复现。 2.JNI DETECTED ERROR IN APPLICATION: jmethodID was NULL 空指针由于java上层设置setFrameCallback(null, 0); iframecallback_fields.onFrame在另外一个线程被置为NULL而以下这段代码没有判空，导致的空指针：env-&gt;CallVoidMethod(mFrameCallbackObj, iframecallback_fields.onFrame, buf); 解决方法为增加空指针判断如下 1234567void UVCPreview::do_capture_callback(JNIEnv *env, uvc_frame_t *frame){...+if (iframecallback_fields.onFrame != NULL) { env-&gt;CallVoidMethod(mFrameCallbackObj, iframecallback_fields.onFrame, buf);+}...} 3.UVCCamera could not open camera:err=-99要检查打开的usb设备是否已经被其他进程打开了/其他进程持有没释放/打开的是不是UVC摄像头，是否打开了错误的其他usb设备 4.其他一些别人发现的bug和修复方法https://github.com/saki4510t/UVCCamera/pull/520https://github.com/saki4510t/UVCCamera/pull/328","link":"/2019/08/27/uvccamera/android_uvccamera_experience_and_bug/"},{"title":"解决Zbar倾斜二维码/条形码识别不出来的情况","text":"在使用Zbar的过程中，有时会遇到二维码/条形码倾斜45%时识别不出来的情况，然而这并不是Zbar的Bug，下面给出两种解决办法。 通过修改Zbar的扫描密度设置（推荐）Zbar在对图像识别时会逐行逐列地扫描，扫描初始化设置里提供了X轴和Y轴的扫描密度的设置，将密度值设置为1，即不跨行扫描，就可以正常识别倾斜的二维码/条形码。 12ImageScanner.setConfig(0, ZBAR_CFG_X_DENSITY, 1);ImageScanner.setConfig(0, ZBAR_CFG_Y_DENSITY, 1); 注意，这里涉及到一个识别速度的问题，很多人将这个值设置为2甚至3，就是为了可以加快识别一帧图像的速度。因为设置为2时，每2行才扫描1行，识别时间更短了，但这也会丢失细节，导致倾斜二维码识别不出来。大部分情况下，Zbar识别一帧图像的时间小于1秒，为了加快一倍的识别速度，丢失识别成功率是不值得的。 使用JNI调用Zbar的情况，要注意检查Java和C代码里对Zbar的初始化设置有没有问题。 通过图像处理矫正再识别将图像矫正再丢给Zbar识别，也是可以的。很多人会使用OpenCV进行图像矫正，这里提供一个处理过程： resize（图像尺寸缩小）-&gt;threshold（二值化）-&gt;erode（几次膨胀腐蚀）-&gt;HoughLines（寻找直线）-&gt;筛除出二维码/一维码的边线，计算出边线的倾斜角度-&gt;warpAffine（对原图像进行仿射变换） 处理后再将图像丢给Zbar识别即可，OpenCV相关代码网上很多，这里就不贴了。 &nbsp;综上所述，这里还是推荐第一种方式。如果还是识别不出来，也许就是图像帧的质量问题，毕竟你觉得清晰的图像，Zbar并不一定觉得细节清晰。","link":"/2018/12/24/zbar/zbar_correct_recognize/"},{"title":"Zbar的使用建议及如何回避存在的Bug","text":"Zbar是一个很强大的开源二维码/条码识别库，但使用时也有几个需要注意的点，以下列出我在使用Zbar 1.0.0版本时得出的经验。 Zbar的使用建议1.减少一帧的识别时间这里不去谈设备性能的差异。单从识别角度说，Zbar识别一帧的时间跟图像帧里码复杂度、帧尺寸大小、需要判断的码类型数量有关，越复杂的二维码/条码和越大尺寸的图像，识别就会越花时间，建议如下： 将二维码和条码从图像帧中截取出来 缩小Camera预览返回的帧尺寸 在Zbar ImageScanner的初始化设置减少识别的条码类型 将Camera预览调成黑白（有可能对识别彩色二维码有影响） 如果机器是多核CPU，可以开多几个线程进行识别操作 另外注意zbar编译时别选择debug版的，debug版的会比release版的慢很多。 2.提高识别成功率Zbar的识别成功率跟图像帧本身的质量有很大关系，图像帧里二维码/条码越是清晰突出，识别成功率越高，同时要避免减低成功率的操作，建议如下： 将Zbar ImageScanner的X、Y轴扫码密度改为1，这同时会加长识别时间12ImageScanner.setConfig(0, ZBAR_CFG_X_DENSITY, 1);ImageScanner.setConfig(0, ZBAR_CFG_Y_DENSITY, 1); 提高Camera预览的图像对比度 对图像帧进行一些处理，如去除噪点，锐化，这里不提二值化因为Zbar自身带了二值化处理 提高图像帧的质量，突出二维码/条码对Zbar识别是很有帮助的，但有些处理也挺耗时的，所以一旦图像处理时间远超Zbar识别时间而且无法接受，那你就得考虑优化处理或者不做处理。 Zbar存在的Bug识别校验码错误的条形码时会返回错误的结果有些类型的条形码是有校验码，比如Code128类型的。绝大部分时候我们扫码时的条码校验码是没问题的，但一旦真的出现校验码错误的条码时，Zbar能保证完全不出错吗，答案是不能保证。Zbar多次识别校验码错误的条码会返回错误的结果，下面举个例子。 我们可以通过修改ZXing的Code128Writer.java类生成校验码错误的Code128条码。 比如下面这张图片是内容为 “66281303A60.2#$@” 的Code128类型条码图： 而这一张是同样内容但校验码错误的条码图： 如果你用Zbar轮流识别这两张图，会发现识别校验码错误图时有概率会返回结果（实际校验码错误就不应该返回任何结果，而Zbar在解析条码也是有判断校验码的），比如会返回 “66281303A60.1#$@” 或者其他数字组合，不但返回了结果还是返回错误内容的结果。但Zbar也会告诉你quality只有1，所以你也可以根据quality不拿这个结果当是正确的结果，但很多时候Zbar的识别不够突出的条码时返回的也是1。&nbsp;解决方式：其实Zbar一开始识别校验码错误的条码是不会出BUG的，但是反复识别就很容易出现，我们可以过一段时间甚至每次识别就重新初始化Scanner和Image，也需要重新设置初始化选项，这样就大大减少出这个BUG的概率。","link":"/2018/12/13/zbar/zbar_usage_and_bug/"}],"tags":[{"name":"Camera","slug":"Camera","link":"/tags/Camera/"},{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"Driver","slug":"Driver","link":"/tags/Driver/"},{"name":"Android Driver","slug":"Android-Driver","link":"/tags/Android-Driver/"},{"name":"SPRD","slug":"SPRD","link":"/tags/SPRD/"},{"name":"Key","slug":"Key","link":"/tags/Key/"},{"name":"PhoneNumber WhiteList","slug":"PhoneNumber-WhiteList","link":"/tags/PhoneNumber-WhiteList/"},{"name":"Android Java framework","slug":"Android-Java-framework","link":"/tags/Android-Java-framework/"},{"name":"Android Map","slug":"Android-Map","link":"/tags/Android-Map/"},{"name":"MapView","slug":"MapView","link":"/tags/MapView/"},{"name":"Map SDK","slug":"Map-SDK","link":"/tags/Map-SDK/"},{"name":"Android KitKat","slug":"Android-KitKat","link":"/tags/Android-KitKat/"},{"name":"Android Kernel","slug":"Android-Kernel","link":"/tags/Android-Kernel/"},{"name":"Android System","slug":"Android-System","link":"/tags/Android-System/"},{"name":"StartUp","slug":"StartUp","link":"/tags/StartUp/"},{"name":"Boot Flow","slug":"Boot-Flow","link":"/tags/Boot-Flow/"},{"name":"Auto Boot","slug":"Auto-Boot","link":"/tags/Auto-Boot/"},{"name":"Alarm","slug":"Alarm","link":"/tags/Alarm/"},{"name":"Power Save","slug":"Power-Save","link":"/tags/Power-Save/"},{"name":"USB","slug":"USB","link":"/tags/USB/"},{"name":"Adb","slug":"Adb","link":"/tags/Adb/"},{"name":"Architecture","slug":"Architecture","link":"/tags/Architecture/"},{"name":"Android System App","slug":"Android-System-App","link":"/tags/Android-System-App/"},{"name":"Incall","slug":"Incall","link":"/tags/Incall/"},{"name":"Dialer","slug":"Dialer","link":"/tags/Dialer/"},{"name":"Video Call","slug":"Video-Call","link":"/tags/Video-Call/"},{"name":"Basic","slug":"Basic","link":"/tags/Basic/"},{"name":"Sensor Driver","slug":"Sensor-Driver","link":"/tags/Sensor-Driver/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Certificate Verify","slug":"Certificate-Verify","link":"/tags/Certificate-Verify/"},{"name":"Decript","slug":"Decript","link":"/tags/Decript/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"Cgroup","slug":"Cgroup","link":"/tags/Cgroup/"},{"name":"File System","slug":"File-System","link":"/tags/File-System/"},{"name":"Pipe","slug":"Pipe","link":"/tags/Pipe/"},{"name":"OpenCV","slug":"OpenCV","link":"/tags/OpenCV/"},{"name":"Android OpenGL","slug":"Android-OpenGL","link":"/tags/Android-OpenGL/"},{"name":"UVCCamera","slug":"UVCCamera","link":"/tags/UVCCamera/"},{"name":"libuvc","slug":"libuvc","link":"/tags/libuvc/"},{"name":"Zbar","slug":"Zbar","link":"/tags/Zbar/"}],"categories":[{"name":"Camera","slug":"Camera","link":"/categories/Camera/"},{"name":"Android","slug":"Android","link":"/categories/Android/"},{"name":"Driver","slug":"Camera/Driver","link":"/categories/Camera/Driver/"},{"name":"System","slug":"Android/System","link":"/categories/Android/System/"},{"name":"Driver","slug":"Android/Driver","link":"/categories/Android/Driver/"},{"name":"Java framework","slug":"Android/Java-framework","link":"/categories/Android/Java-framework/"},{"name":"Android Camera","slug":"Camera/Android-Camera","link":"/categories/Camera/Android-Camera/"},{"name":"System App","slug":"Android/System-App","link":"/categories/Android/System-App/"},{"name":"Basic","slug":"Camera/Basic","link":"/categories/Camera/Basic/"},{"name":"Map","slug":"Android/Map","link":"/categories/Android/Map/"},{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"OpenCV","slug":"OpenCV","link":"/categories/OpenCV/"},{"name":"OpenGL","slug":"OpenGL","link":"/categories/OpenGL/"},{"name":"UVCCamera","slug":"Android/UVCCamera","link":"/categories/Android/UVCCamera/"},{"name":"Zbar","slug":"Zbar","link":"/categories/Zbar/"},{"name":"System","slug":"Linux/System","link":"/categories/Linux/System/"},{"name":"IPC","slug":"Linux/IPC","link":"/categories/Linux/IPC/"}]}