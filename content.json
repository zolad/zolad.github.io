{"pages":[],"posts":[{"title":"展讯物理按键配置经验","text":"展讯系统驱动配置物理按键，首先查看硬件原理图，找到对应物理按键的管脚，比如按键5接的是gpio125 1.打开kernel/arch/arm/boot/dts/对应项目的.dts文件修改gpio_keys下的配置，gpios修改对应的gpio引脚号 1234567891011gpio_keys { key_5 { label = \"5 Key\"; linux,code = &lt;6&gt;;- gpios = &lt;&amp;ap_gpio 92 1&gt;;+ gpios = &lt;&amp;ap_gpio 125 1&gt;; gpio-key,wakeup; gpio-key,level-trigger; };} linux,code对应的就是KEY CODEgpio-key,wakeup代表按下时如果系统正在休眠会触发唤醒gpio-key,level-trigger 表示增加电平触发判断 2.打开u-boot15/board/spreadtrum/对应项目的pinmap .c文件 对照平台GPIO_Spec的xls表，找到gpio125对应的Ball Name，修改Fuction为默认gpio功能:BITS_PIN_AF(3) 12{REG_PIN_RTCK_LTE, BITS_PIN_AF(3)},{REG_MISC_PIN_RTCK_LTE, BITS_PIN_DS(1)|BIT_PIN_NULL|BIT_PIN_NUL|BIT_PIN_SLP_AP|BIT_PIN_SLP_NUL|BIT_PIN_SLP_OE},","link":"/2019/02/07/android_driver/sprd_key_driver_experience/"},{"title":"Android KitKat(4.4)单独编译Kernel","text":"这篇文章教你如何在没有全部Android源码，只有kernel文件夹时编译boot.img。另外这里需要从4.4的源码或者平台源码提取一些工具。 Android源码里的Kernel文件夹是GNU协议的，所以厂家的驱动操作细节基本在其他目录（比如vendor）下的Hal代码里。 如果想熟悉Android大概编译流程的话，最直接的就是看/build/core/Makefile的代码，这样你就会清楚每个img文件是从那些文件里生成的，用的什么参数、工具也一目了然。 关于安卓各版本的差异和平台差异安卓各版本差异Android不同版本编译时，需要的JDK版本和C编译工具版本是不一样的，4.4用的JDK版本是1.6，而C的编译器版本可以查看/build/core/Makefile的代码来确认。 平台差异展讯、MTK、高通下的有些平台在编译完源码后会对img进行签名加密操作，如果涉及到签名加密最好是拥有对应平台的源码，从中提取签名加密工具和参数。 编译脚本的编写文件目录├── arm-eabi-4.8 // c编译器├── build_tools //编译相关工具├── config│ ├── kernel_config //kernel编译的config文件，需要从kernel/arch/arm/configs下找到对应机器类型的config文件，或者直接从整体源码编译后的out目录里提取│ └──xxxxx-native.dtb //kernel对应机器类型的dts文件，用来生成dt.img，需要从kernel/arch/arm/boot/dts目录里提取├── flash│ └── ramdisk.img //整体源码编译后的ramdisk.img├── kernel //源码文件├── packimage_scripts //签名加密工具，不一定需要，看平台├── build.sh //编译脚本 编写编译脚本build.sh编译的过程，简单来说，就是先根据config文件编译kernel文件夹，找到对应机器的dts文件用dtbTool生成dt.img,然后使用mkbootimg工具，合并kernel的编译结果Image、ramdis.img、dt.img生成boot.img。 最后如果需要签名加密在用签名加密工具对boot.img进行签名加密。 12345678910111213141516make -j8 -l8 -C ./kernel cleanrm -rf outmkdir outrm flash/dt.img flash/boot.img flash/boot-sign.imgcp ./config/kernel_config out/.configmake -j4 -C ./kernel ARCH=arm CROSS_COMPILE=$PWD/arm-eabi-4.8/bin/arm-eabi- O=$PWD/out/find out/arch/arm/boot/dts/ -name *.dtb ! -name xxxxx.dtb | xargs -I{} rm {}./build_tools/dtbTool -o flash/dt.img -s 2048 -p out/scripts/dtc/ out/arch/arm/boot/dts/./build_tools/mkbootimg --kernel out/arch/arm/boot/Image --ramdisk flash/ramdisk.img --cmdline console=ttyS1,115200n8 --base 0x00000000 --pagesize 2048 --dt flash/dt.img --kernel_offset 0x00008000 --ramdisk_offset 0x05400000 --output flash/boot.imgsource packimage_scripts/packimage.sh flash/boot.img &nbsp; 这里还得说下，因为平台的不同，编译过程的参数、指令、文件都可能有差异，最好是根据/build/core/Makefile里的过程走，也可以参照其他kernel编译的相关文章。","link":"/2018/10/28/android_kernel/android_kitkat_kernel_build/"},{"title":"Android Camera Driver平台(展讯、MTK)适配经验","text":"展讯平台1.项目对应kernel/dts文件配置12345678910111213141516171819202122232425262728293031&amp;i2c0 { status = \"okay\"; clock-frequency = &lt;400000&gt;; sensor_main: sensor-main@3c { compatible = \"sprd,sensor-main\"; reg = &lt;0x3c&gt;; clock-names = \"clk_src\", \"sensor_eb\", \"clk_96m\", \"clk_76m8\", \"clk_48m\", \"clk_26m\"; clocks = &lt;&amp;clk_sensor0&gt;, &lt;&amp;clk_mm_ckg_gates 1&gt;, &lt;&amp;clk_twpll_96m&gt;, &lt;&amp;clk_twpll_76m8&gt;, &lt;&amp;clk_twpll_48m&gt;, &lt;&amp;ext_26m&gt;; vddio-supply = &lt;&amp;vddcamio&gt;; vddcama-supply = &lt;&amp;vddcama&gt;; vddcamd-supply = &lt;&amp;vddcamd&gt;; vddcammot-supply = &lt;&amp;vddcammot&gt;; reset-gpios = &lt;&amp;ap_gpio 37 0&gt;; power-down-gpios = &lt;&amp;ap_gpio 39 0&gt;; host = \"dcam0\"; port { sensor_main_0: endpoint { remote-endpoint = &lt;&amp;phy0_out&gt;; }; }; };}; (1).compatible = “sprd,sensor-main”， 这里不需要配摄像头的I2C Device Address，alps/kernel/drivers/misc/sprd_camera/sensor/sprd_sensor_drv.c 会读取这里的id进行处理具体的I2C地址在sensor驱动中配置 (2).reset-gpios，power-down-gpios可通过查看机器板子的原理图来确定对应gpio的引脚修改 2.项目对应device/../../BoardConfig.mk配置(1).配上前后置摄像头对应Camera Sensor的型号，如：CAMERA_SENSOR_TYPE_BACK := “sp2509 c2590”CAMERA_SENSOR_TYPE_FRONT := “gc030a” (2).若模组厂打样时摄像头拍照方向为横屏，则TARGET_BOARD_BACK_CAMERA_ROTATION/TARGET_BOARD_FRONT_CAMERA_ROTATION设置为false，否则设置为true。 (3).配置Camera支持的分辨率 123#select camera 2M,3M,5M,8M,13M,16M,21MCAMERA_SUPPORT_SIZE := 2MFRONT_CAMERA_SUPPORT_SIZE := 2M 3.vendor/sprd/../../libcamera配置和添加Camera驱动代码(1).在vendor/sprd/../../libcamera/sensor下放置已经适配了平台的sensor_drv代码，如果没有已经适配了平台的驱动代码，那只能按平台已有的驱动代码为模板按硬件文档进行适配修改。注意修改时尽量按平台已有的camera驱动代码为规范。这方面可以自己修改也可以找FAE帮忙。 (2).修改vendor/sprd/../../libcamera/sensorsensor_cfg.c，配置新Camera 12345678#ifdef OV8856extern SENSOR_INFO_T g_ov8856_mipi_raw_info;#endif在对应的sensor_infor_tab添加配置，分别是camera module name/camera name/sensor info/af/otp：#ifdef OV8856 {MODULE_SUNNY, \"ov8856\", &amp;g_ov8856_mipi_raw_info, {&amp;dw9763a_drv_entry, 0}, &amp;ov8856_cmk_drv_entry},#endif MTK平台1.kernel-4.4/drivers/misc/mediatek/imgsensor/inc/kd_imgsensor.h配置123#define S5K4H8_SENSOR_ID 0x4088#define SENSOR_DRVNAME_S5K4H8_MIPI_RAW \"s5k4h8_mipi_raw\" 2.项目对应kernel-4.4/arch/arm/configs/…/xxx_defconfig配置可通过查看device目录下项目mk文件里 KERNEL_DEFCONFIG 指向的是哪个config文件CONFIG_CUSTOM_KERNEL_IMGSENSOR=”s5k4h8_mipi_raw” 带debug标签的用于编译过程中查看调试信息 3.项目对应ProjectConfig.mk配置1234CUSTOM_HAL_IMGSENSOR = s5k4h8_mipi_rawCUSTOM_HAL_MAIN_IMGSENSOR = s5k4h8_mipi_rawCUSTOM_KERNEL_IMGSENSOR = s5k4h8_mipi_rawCUSTOM_KERNEL_MAIN_IMGSENSOR = s5k4h8_mipi_raw 4.kernel-4.4/drivers/misc/mediatek/imgsensor/src/xxx/xxx/imgsensor_sensor_list.c添加123#if defined(S5K4H8_MIPI_RAW) {S5K4H8_SENSOR_ID, SENSOR_DRVNAME_S5K4H8_MIPI_RAW, S5K4H8_MIPI_RAW_SensorInit},#endif 5.kernel-4.4/drivers/misc/mediatek/imgsensor/src/xxx/xxx/imgsensor_sensor_list.h添加1UINT32 S5K4H8_MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc); 6.kernel-4.4/drivers/misc/mediatek/imgsensor/src/xxx/xxx 配置和添加Camera sensor驱动代码7.kernel-4.4/drivers/misc/mediatek/imgsensor/src/xxx/xxx/imgsensor_cfg_table.c 配置上下电时序12345678910111213141516#if defined(S5K4H8_MIPI_RAW) { SENSOR_DRVNAME_S5K4H8_MIPI_RAW, { {SensorMCLK, Vol_High, 0}, {PDN, Vol_Low, 5}, {RST, Vol_Low, 5}, {DVDD, Vol_1200, 0}, {AVDD, Vol_2800, 0}, {DOVDD, Vol_1800, 5}, {AFVDD, Vol_2800, 0}, {PDN, Vol_High, 5}, {RST, Vol_High, 5} }, },#endif 8.vendor/mediatek/proprietary/custom/xxxx/hal/imgsensor/ 添加对应Camera驱动代码9.vendor/mediatek/proprietary/custom/xxxx/hal/imgsensor_src/sensorlist.cpp添加123#if defined(S5K4H8_MIPI_RAW) RAW_INFO(S5K4H8_SENSOR_ID, SENSOR_DRVNAME_S5K4H8_MIPI_RAW, S5K4H8_CAM_CALGetCalData),#endif 10.vendor/mediatek/proprietary/custom/xxxx/hal/lens/src/lenslist.cpp添加#if defined(DW9714AF_S5K4H8_SUNWIN_P130) extern PFUNC_GETLENSDEFAULT pDW9714AF_S5K4H8_SUNWIN_P130_getDefaultData; #endif","link":"/2019/12/07/android_driver/camera_driver_config_experience/"},{"title":"Android 实现电话号码（接听/拨号/短信）白名单","text":"我遇到一个需求，需要实现电话号码的白名单，除了通讯录里的号码，所有来电短信都要屏蔽掉。 Android 7.0后提供了一个电话号码黑名单的功能，可以拦截对应号码的电话和短信，即Android N BlockedNumberContract原生黑名单。 所以我这里就直接利用这个模块的函数，再此之上增加白名单判断。 白名单电话接听拦截和短信拦截这里直接利用BlockedNumberContract框架里的关键判断类BlockChecker，BlockChecker的isBlocked函数会返回一个bool值，根据这个bool值，BlockedNumberContract框架会决定是否拦截对应号码的电话和短信。 修改位置 frameworks\\opt\\telephony\\src\\java\\com\\android\\internal\\telephony\\BlockChecker.java 123456789101112131415161718192021222324252627282930313233343536 /** * Returns {@code true} if {@code phoneNumber} is blocked. * &lt;p&gt; * This method catches all underlying exceptions to ensure that this method never throws any * exception. */ public static boolean isBlocked(Context context, String phoneNumber) { boolean isBlocked = false; long startTimeNano = System.nanoTime(); try {+ //注释掉这部分原生判断，会读取BlockedNumberContract数据库里的名单作对比+ // if (BlockedNumberContract.SystemContract.shouldSystemBlockNumber(+ // context, phoneNumber)) {+ // Rlog.d(TAG, phoneNumber + \" is blocked.\");+ // isBlocked = true;+ // }+ //新增一个shouldBlockNumber函数，这里可以根据自己需求，从什么数据库读取白名单来判断对应号码是否该拦截+ if (shouldBlockNumber( context, phoneNumber)) {+ Log.d(TAG, phoneNumber + \" is blocked.\");+ isBlocked = true;+ } } catch (Exception e) { Rlog.e(TAG, \"Exception checking for blocked number: \" + e); } int durationMillis = (int) ((System.nanoTime() - startTimeNano) / 1000000); if (durationMillis &gt; 500 || VDBG) { Rlog.d(TAG, \"Blocked number lookup took: \" + durationMillis + \" ms.\"); } return isBlocked; } 如果不想短信受控制，可以修改frameworks/opt/telephony/src/java/com/android/internal/telephony/InboundSmsHandler.java 12345678910111213141516171819202122232425- block = BlockChecker.isBlocked(mContext, tracker.getDisplayAddress());+ // not block + // block = BlockChecker.isBlocked(mContext, tracker.getDisplayAddress());- block = BlockChecker.isBlocked(mContext,- cursor.getString(PDU_SEQUENCE_PORT_PROJECTION_INDEX_MAPPING- .get(DISPLAY_ADDRESS_COLUMN)));+ // not block + // block = BlockChecker.isBlocked(mContext,+ // cursor.getString(PDU_SEQUENCE_PORT_PROJECTION_INDEX_MAPPING+ // .get(DISPLAY_ADDRESS_COLUMN)));``` frameworks/opt/telephony/src/java/com/android/internal/telephony/WapPushOverSms.java``` - if (nInd.getFrom() != null- &amp;&amp; BlockChecker.isBlocked(mContext, nInd.getFrom().getString())) {++ // not block + // &amp;&amp; BlockChecker.isBlocked(mContext, nInd.getFrom().getString())+ if (nInd.getFrom() != null) { 电话拨号拦截修改位置 proprietary/packages/services/Telecomm/src/com/android/server/telecom/CallIntentProcessor.java 123456789101112131415161718192021222324252627 /** * Processes CALL, CALL_PRIVILEGED, and CALL_EMERGENCY intents. * * @param intent Call intent containing data about the handle to call. */ static void processOutgoingCallIntent( Context context, CallsManager callsManager, Intent intent) { if (phoneNumber != null) { if (!PhoneNumberUtils.isUriNumber(phoneNumber)) { phoneNumber = PhoneNumberUtils.convertAndStrip(phoneNumber); } }+ if (shouldBlockNumber(context,phoneNumber)) {+ + Log.d(CallIntentProcessor.class,phoneNumber + \" is blocked.\");++ return;+ } }","link":"/2019/02/08/android_java_framework/android_phone_whitelist/"},{"title":"Android Java framework各种各样的修改经验","text":"顺手记录下修改系统时的经验,网上很容易就能搜到的就不记录了 修改下拉快捷菜单栏的菜单列表:主要搜索qstile相关的类 xxxx/packages/apps/SystemUI/res/values/config.xml 123456789&lt;!-- The default tiles to display in QuickSettings --&gt;&lt;string name=\"quick_settings_tiles_default\" translatable=\"false\"&gt;wifi,bt,dnd,rotation,battery,cell,cast&lt;/string&gt;&lt;!-- Tiles native to System UI. Order should match \"quick_settings_tiles_default\" --&gt;&lt;string name=\"quick_settings_tiles_stock\" translatable=\"false\"&gt;wifi,cell,battery,dnd,rotation,bt,location,hotspot,inversion,saver,work,cast,night&lt;/string&gt; 如何在framework层获取当前api被调用时的进程对应的app的application context:ActivityThread.currentActivityThread().getApplication() 去除@hide 但 make update-api和编译出错解决方法:如果make update-api报错的话要看对应方法里是不是有其他@hide的类或方法,比如参数的类是hide的,调用的api是hide的要将所有相关的变量和api都去除hide,才能update成功比如:void aaa(B bbb){ ccc(bbb);}要保证B的类和ccc函数是非hide的 如何修改系统通话UI界面:路径为：packages/apps/Dialer/java/com/android/incallui/incall/implvendor/xxxxx/proprietary/packages/apps/Dialer/java/com/android/incallui/incall/impl InCallFragment ，InCallButtonGridFragment是关键类，有很多代理类和presenter类 UsbManager在连接usb设备时需要request权限才能连接到usb设备,如何跳过申请权限的弹框,默认赋予权限呢可以修改framework下的UsbUserSettingsManager: 1234567891011121314151617181920212223242526272829 // Temporary mapping USB device name to list of UIDs with permissions for the device private final HashMap&lt;String, SparseBooleanArray&gt; mDevicePermissionMap = new HashMap&lt;&gt;(); // Temporary mapping UsbAccessory to list of UIDs with permissions for the accessory private final HashMap&lt;UsbAccessory, SparseBooleanArray&gt; mAccessoryPermissionMap = new HashMap&lt;&gt;();两个hashmap分别储存的uid和对应的usbdevice,只要存在即允许了权限 public boolean hasPermission(UsbDevice device, String packageName, int uid) { synchronized (mLock) { if (isCameraDevicePresent(device)) { //camera权限,usb camera需要额外的camera权限 if (!isCameraPermissionGranted(packageName, uid)) { return false; } } //如果是系统uid,或者mDisablePermissionDialogs 设置禁用usb权限询问框,则默认拥有权限 if (uid == Process.SYSTEM_UID || mDisablePermissionDialogs) { return true; } //获取对应usbdevice的已允许权限uid,如果uid存在则判断拥有权限 SparseBooleanArray uidList = mDevicePermissionMap.get(device.getDeviceName()); if (uidList == null) { return false; } return uidList.get(uid); } } 系统编译自定义覆盖代码资源文件： Android Overlay机制允许在不修改packages中apk的情况下，来自定义 framework/package/vendor中的资源文件，实现资源的定制。来达到显示不同的UI得目的 PRODUCT_PACKAGE_OVERLAYS := device/vendor-name/device-name/product-name/overlay Or： DEVICE_PACKAGE_OVERLAYS := device/vendor-name/device-name/common/overlay 注意只能修改xml之类的资源文件,java文件无法替换。 代码文件： 通过修改 envsetup 和 lunch执行的mk文件，比如在build/core/envsetup.mk添加复制替换代码： $(shell \\cp -rf vendor/mediatek/xxxx/Camera.java frameworks/base/core/java/android/hardware/Camera.java) 通讯录如何判断是否是sim卡储存的号码：12345678910111213 private static final String ACCOUNT_TYPE_SIM = \"SIM Account\"; private static final String ACCOUNT_TYPE_USIM = \"USIM Account\"; private static final String ACCOUNT_TYPE_RUIM = \"RUIM Account\"; private static final String ACCOUNT_TYPE_CSIM = \"CSIM Account\";private static boolean isAccountTypeIccCard(String accountTypeString) { boolean isIccCardAccount = (ACCOUNT_TYPE_SIM.equals(accountTypeString) || ACCOUNT_TYPE_USIM.equals(accountTypeString) || ACCOUNT_TYPE_RUIM.equals(accountTypeString) || ACCOUNT_TYPE_CSIM.equals(accountTypeString)); //Log.d(TAG, \"account \" + accountTypeString + \" is IccCard? \" + isIccCardAccount); return isIccCardAccount; } app监听短信接收，只能监听到短短信，监听不到长短信：检查系统短信应用Mms，长短信是需要系统短信应用去操作拼接的 修改系统蓝牙功能支持类型vendor/xxxx/proprietary/packages/apps/Bluetooth/res/values/config.xml 修改如下对应功能支持的值 123456789101112131415161718&lt;bool name=\"profile_supported_a2dp\"&gt;true&lt;/bool&gt;&lt;bool name=\"profile_supported_a2dp_sink\"&gt;false&lt;/bool&gt;&lt;bool name=\"profile_supported_hdp\"&gt;false&lt;/bool&gt;&lt;bool name=\"profile_supported_hs_hfp\"&gt;true&lt;/bool&gt;&lt;bool name=\"profile_supported_hfpclient\"&gt;false&lt;/bool&gt;&lt;bool name=\"profile_supported_hid\"&gt;false&lt;/bool&gt;&lt;bool name=\"profile_supported_opp\"&gt;false&lt;/bool&gt;&lt;bool name=\"profile_supported_pan\"&gt;false&lt;/bool&gt;&lt;bool name=\"profile_supported_pbap\"&gt;false&lt;/bool&gt;&lt;bool name=\"profile_supported_gatt\"&gt;true&lt;/bool&gt;&lt;bool name=\"pbap_include_photos_in_vcard\"&gt;false&lt;/bool&gt;&lt;bool name=\"pbap_use_profile_for_owner_vcard\"&gt;false&lt;/bool&gt;&lt;bool name=\"profile_supported_map\"&gt;false&lt;/bool&gt;&lt;bool name=\"profile_supported_avrcp_controller\"&gt;false&lt;/bool&gt;&lt;bool name=\"profile_supported_sap\"&gt;false&lt;/bool&gt;&lt;bool name=\"profile_supported_pbapclient\"&gt;false&lt;/bool&gt;&lt;bool name=\"profile_supported_mapmce\"&gt;false&lt;/bool&gt;&lt;bool name=\"profile_supported_hidd\"&gt;false&lt;/bool&gt;","link":"/2019/01/05/android_java_framework/android_java_framework_experience/"},{"title":"Android 展讯/MTK Alarm白名单设置","text":"目前大部分应用都会通过AlarmManager设置 alarm 来定时或周期唤醒系统来做一些操作。这种随机的 alarm 唤醒会增加系统的待机功耗。所以平台厂商为了功耗优化，一方面禁止了非白名单的第三方应用在系统休眠时唤醒系统，一方面做了心跳对齐的机制（即将这些唤醒时间杂乱的alarm修改为统一时间唤醒）。 当然Android M开始也引入了Doze机制，Doze机制的白名单和平台的Alarm白名单最好都配置上对应的包名。 展讯平台修改路径：vendor\\sprd\\platform\\frameworks\\native\\data\\etc\\appPowerSaveConfig.xml 在配置文件中添加应用包名 1&lt;package name=\"com.my.app\" optimize=\"1\" alarm=\"2\" wakelock=\"2\" network=\"0\" autolaunch=\"2\" secondarylaunch=\"2\" lockscreencleanup=\"2\" consumertype=\"0\" /&gt; optimize 对应是否对该应用进行省电优化的总开关，0 为不优化，1 为优化 alarm 对应待机唤醒优化，0 对应自动，1 对应优化，2 对应不优化 wakelock 对应待机休眠优化，0 对应自动，1 对应优化，2 对应不优化 MTK平台修改路径：frameworks/base/core/java/com/mediatek/amplus/config/alarmplus.config 如果没有该文件就创建一个，在配置文件中添加应用包名 121com.my.app2com.my.app2 另外将该文件拷贝到system/etc下 123#alarmplusPRODUCT_COPY_FILES += \\vendor/mediatek/proprietary/frameworks/opt/amplus/config/alarmplus.config:system/etc/alarmplus.config:mtk","link":"/2019/04/02/android_system/android_sprd_mtk_alarm_group_whitelist/"},{"title":"Android启动流程-个人笔记","text":"网上关于android启动流程的文章很多，对于我个人而言想额外补充一些知识点总结下。下面是一张网上很常见的android 启动流程图： 所以我就顺着这张流程图从上到下总结一下. Boot RomBoot Rom是嵌入在ARM芯片上的，当设备按下power键上电后，设备启动加电自检后从固定的地址开始执行，随后Boot Rom加载Bootloader代码进入内存，然后执行。 BootLoaderBootLoader类似windows上的BIOS程序，嵌入式系统有很多开源的BootLoader，比如很多Android平台厂商使用的U-boot（全名An Universal boot loader）就是开源的BootLoader。 下图是Linux系统和Android系统(MTK平台)启动流程差别，左边为Linux系统，右边为Android系统(MTK平台)。 我们根据上面的对比图，可以发现Android的启动流程设计和Linux的区别。 这里先说一点，MTK平台为了防止芯片被HACK，特意加了Pre-Loader这段程序，Pre-Loader为了保护芯片包含了一些安全功能和做一些安全检查，安全检查没问题后才加载启动U-boot程序，但Pre-Loader不是所有Android平台都有的，比如展讯的一些平台就没有。 BootLoader主要工作包括配置系统Memory、加载kernel的image、传递参数给linux kernel、获取芯片信息、跳转到kernel执行。 当然BootLoader还有一些其他的工作，比如设备在关机状态下，按下开机键，此时设备执行到BootLoader层，设备有最底启动电压，BootLoader里的代码会判断当前电池电压是否满足最低启动电压，来决定是否启动设备。 还有判断进入recovery模式/充电模式/开机模式等，也是在这一层做判断。 Kernel在这一步会加载Linux内核，内核启动时，会设置缓存、被保护存储器、计划列表，加载驱动等等。设备很多硬件功能就是在这一层开始支持使用的。当内核完成系统设置，它会启动init进程。 另外linux的watchdog进程也是这时候启动的，watchdog是为了保证系统正常运行，或者从死循环，死锁等一场状态退出的一种机制。防止系统死机卡死，但如果系统在bootloader阶段卡死，那watchdog就不起作用了。 initinit进程（/system/core/init）是Linux系统第一个在用户空间创建的进程。Linux 操作系统和驱动程序运行在内核空间，应用程序运行在用户空间。 用户空间和内核空间使用的内存区域也是划分开的，也是为了避免用户空间的操作影响到内核空间。 init进程会启动一些关键的系统进程，比如servicemanager服务管理、zygote孵化程序、surfaceflinger、mediaserver、Property Service(我们常用的系统属性，System Properties就是由这个服务管理的)等。 init目录下有自己的语法脚本，比如init.rc、init.usb.rc、init.trace.rc等。 ZygoteZygote负责创建JVM的环境，工作包括创建Dalvik虚拟机实例、创建system_server进程、创建socket server进程（让其他进程和zygote进程通信）、DVM预加载初始化核心的库和资源文件。 所有apk的进程都是由Zygote fork出来的，由于是linux父子进程的关系，DVM加载的core library和资源（一般是只读的）也可以被app进程使用,app进程只需要加载自己独有的资源，这样就节省下了内存。 Linux的fork()使用写时拷贝（copy-on-write）页实现。如下图所示，创建P2子进程，内核只为P2子进程创建虚拟空间，不分配物理内存，和P1父进程共享物理空间，当P1父进程中有更改相应段的行为发生时，才为子进程分配物理空间。 所以Zygote在创建子进程前加载的资源可以直接被子进程调用，同为了避免写入资源造成重新分配问题，所以资源一般都是只读的。 Android上层的所有程序都是运行在Dalvik VM上的。DVM只执行.dex的Dalvik executable文件。每一个Android应用程序在底层都对应有一个独立的DVM实例并在其解释下执行。 System ServerSystem Server进程由Zygote进程fork出来，这个进程加载了其他很多关键的Service，比如PMS、WMS、AMS等，从这一层开始，各种各样的Service会进行扫描安装apk，启动Launcher，关闭开机动画，app启动运行，窗口显示管理等等的工作，这一层开始后网上的文章已经有很多了，就不重复了。 这一篇文章注重概括android启动流程和补充一些细节，比较少讲android上层的启动知识点，时间已到深夜，晚安。","link":"/2019/05/13/android_system/android_boot_flow_self_note/"},{"title":"使用OpenCV对二维码/条形码进行矫正","text":"OpenCV提供了很多图像处理的API，我们可以利用这些API做一些矫正四边形物体比如二维码/条码的工作。 大概过程如下： resize（图像尺寸缩小）-&gt;threshold（二值化）-&gt;erode（几次膨胀腐蚀）-&gt;HoughLines（寻找直线）-&gt;筛除出二维码/一维码的边线，计算出边线的倾斜角度-&gt;warpAffine（对原图像进行仿射变换） 下面贴具体的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104void correctImage(unsigned char *nv21, int width, int height, unsigned char *dest) { int resizeWidth = width/2; int resizeHeight = height/2; //初始化需要使用的Mat Mat imgMat(height * 3 / 2, width, CV_8UC1, nv21); //灰度图Mat Mat grayMat(height, width, CV_8UC1); //最终结果的Mat Mat resultMat(height, width, CV_8UC1,dest); //过程Mat Mat innerMat(resizeHeight, resizeWidth, CV_8UC1); Mat binMat(resizeHeight, resizeWidth, CV_8UC1); //将yuv420sp转为灰度图 cvtColor(imgMat, grayMat, CV_YUV420sp2GRAY); //缩小图像尺寸以减少后面图像处理工作的耗时 resize(grayMat, innerMat, Size(resizeWidth, resizeHeight)); //自适应二值化参数 int blockSize = 3; int constValue = 5; const int maxVal = 255; //自适应二值化 adaptiveThreshold(innerMat, binMat, maxVal,ADAPTIVE_THRESH_GAUSSIAN_C, THRESH_BINARY, blockSize, constValue); int rectWidth = resizeWidth / 5; int rectHeight = resizeHeight / 5; int centerX = resizeWidth / 2, centerY = resizeHeight / 2; Mat element = getStructuringElement(2, Size(7, 7)); //膨胀腐蚀 for (int i = 0; i &lt; 2; i++) { erode(innerMat, innerMat, element); i++; } erode(innerMat, binMat, element); binMat = innerMat - binMat; //寻找直线 vector&lt;Vec2f&gt; lines; HoughLines(binMat, lines, 1, CV_PI / 150, 90, 0, 0); LOGV(\"OpenCV_CorrectImage寻找边线，边线数量:%d\", lines.size()); //由于边线可能有很多，这里最多取8条边线来计算角度 int lineNum = lines.size() &gt; 8 ? 8 : lines.size(); float sum = 0; //num参数记录倾斜的线条的数量 int num = 0; for (int i = 0; i &lt; lineNum; i++) { float theta = lines[i][1]; //各个角度对应的theta值,相当于:角度/180*PI //90-&gt;1.5708 //100 -&gt; 1.7453 //80 -&gt; 1.3963 //95-&gt;1.6580 //85-&gt;1.4835 //0 -&gt;0 //5-&gt;0.0872 //10 -&gt; 0.1745 //12 -&gt;0.209 //15 -&gt;0.2618 //180-&gt; 3.1415 //170 -&gt;2.967 // 过滤掉角度正常的，0-15度，80-100 ,170-180 if ((theta &gt;= 0 &amp;&amp; theta &lt;= 0.2618) || (theta &gt;= 1.3963 &amp;&amp; theta &lt;= 1.7453) || (theta &gt;= 2.967 &amp;&amp; theta &lt;= 3.1416)) { } else { if (theta &gt;= 1.5708) theta = theta - 1.5708; LOGV(\"OpenCV_CorrectImage寻找边线，角度:%f\", theta); sum += theta; num += 1; } } //需要矫正 if (num &gt; 0) { float average = sum / num; //转成角度 double angle = average / CV_PI * 180; LOGV(\"OpenCV_CorrectImage寻找边线，角度:%f\", angle); //如果矫正角度大于5才矫正 if (angle &gt; 5) { Point2f center; center.x = float(width / 2.0); center.y = float(height / 2.0); Mat M = getRotationMatrix2D(center, angle, 1); //仿射变换，背景色填充为黑色 warpAffine(grayMat, resultMat, M, resultMat.size(), 1, 0, Scalar(255)); LOGV(\"OpenCV_CorrectImage角度变换完成\"); } }} OpenCV很多图像处理的API有各种各样的参数，不同的参数会适合不同的场景，所以以上代码也不可能适应所有场景下的二维码/条码图片。","link":"/2018/12/19/opencv/opencv_correct_image/"},{"title":"记录下使用OpenGL的经验","text":"此篇文章记录下自己在android平台上使用opengl的经验，顺便记录下自己开源项目使用opengl的思路，内容会很零碎，因为只是随便整理记录下。 opengl里的program 是可以复用的 但是shader一旦绑定是不能复用的，一个program绑定一个顶点shader和一个片段shader opengl滤镜制作 滤镜实际就是对图像的像素点色彩值进行多次加工，代码实现上就是自定义shader进行色彩处理 例如亮度，就是r,g,b分别加上亮度r+0.1 ,g+0.1,b+0.1hsv是把rgb转hsv，再叠加 另外可以使用混合模式，减少渲染次数 https://cloud.tencent.com/developer/article/1132385 “终端图像处理系列 - OpenGL混合模式的使用” https://blog.csdn.net/junzia/article/details/76580379 “Android OpenGLES2.0（十八）——轻松搞定Blend颜色混合” 自己的开源项目BubbleTextureview实现思路 具体是自定义绘制了一个气泡状的模型GLbubbleGeometry，另外基于GLTextureView，将TextureView的图像数据当纹理显示。 GLtextureView 是模仿根据Glsurfaceview 改过来的，新建了一个Glthread 去链接EGL, 相关知识搜索OPENGL GLtextureView相关文章。 float[] vertices = new float[verticesSize]; 保存了所有顶点，不重复short[] indices = new short[indicesSize]; 保存了三角形绘制的点顺序具体就是0，1，2，3，2，3，4，3，4，5 .。。。 这样，绘制根据这个点顺序去绘制 topleftradius 是0-1的百分比圆角半径长度，适应opengl的0-1坐标系 求圆角的多个三角形点坐标时用vertices[currentOffset + 5] = center[0] + radius[0] * (float) Math.cos(rads);x坐标为 中心点 + 半径*cos角度 vertices[currentOffset + 6] = center[1] + radius[1] * (float) Math.sin(rads);y坐标为 中心点 + 半径*sin角度 π就是逆时针180°，-π就是顺时针180° MediaCodec 要将surface里的数据转为混合为mp4,必须要4.3以上的手机，因为EGLExt.eglPresentationTimeANDROID(mEGLDisplay, mEGLSurface, nsecs); 这个设置surface时间的方法是必须api18的. 如果不用MediaMuxer混合视频，可以用mp4parser这个开源库，就能在4.1的手机上转码视频为mp4","link":"/2018/05/19/opengl/opengl_experience/"},{"title":"Android如何屏蔽通话界面的视频彩铃","text":"当电话呼叫对方时，如果对方设置了视频彩铃，则会在呼叫页面出现运营商的视频和彩铃，可以通过修改系统应用中的Dialer App的incall页面来屏蔽。 比如MTK平台的Dialer App，路径如下：vendor/mediatek/proprietary/packages/apps/Dialer/java/com/android/incallui/call/DialerCall.java可以通过如下修改： 1234 public boolean isVideoCall() {- return getVideoTech().isTransmittingOrReceiving();+ return false;//getVideoTech().isTransmittingOrReceiving(); } 或者修改vendor/mediatek/proprietary/packages/apps/Dialer/java/com/android/incallui/InCallActivity.java 的private static ShouldShowUiResult getShouldShowVideoUi() 方法使其不显示视频页面","link":"/2019/11/06/android_java_framework/android_dialer_app_video_incall/"},{"title":"Android UVCCamera/libuvc遇到的卡死崩溃bug和解决方法","text":"分享下debug uvccamera/libuvc这些so库遇到的卡死崩溃问题和思路 1.UVCCamera执行stopPreview或release时阻塞卡死在多次重复打开关闭uvc摄像头的时候，上层调用stopPreview/release会概率性卡死，经过调试一步步定位调用函数和阻塞住的位置 android java层调用略，下面直接从so库的代码开始； –&gt;UVCCamera/UVCCamera.cpp-stopPreview() –&gt;UVCCamera/UVCPreView.cpp-stopPreview()这里设置mIsRunning = false;停止预览帧处理；调试发现，在下面这一句代码阻塞住没有往下走了：pthread_join(preview_thread, NULL) != EXIT_SUCCESS;pthread_join会阻塞到preview_thread预览线程执行结束为止，所以预览处理没有正常结束；–&gt;UVCCamera/UVCPreview.cpp-do_preview()结束预览时会停止libuvc的流处理uvc_stop_streaming(mDeviceHandle);，所以流处理没有正常结束；–&gt;libuvc/stream.c-uvc_stop_streaming()–&gt;libuvc/stream.c-uvc_stream_close()–&gt;libuvc/stream.c-uvc_stream_stop()这一步停止流的传输，并将所有流转换器都释放掉：strmh-&gt;running = 0;并遍历调用libusb_cancel_transfer(strmh-&gt;transfers[i]);至于关键的阻塞代码如下： 12345678910/* Wait for transfers to complete/cancel */ for (; 1 ;) { for (i = 0; i &lt; LIBUVC_NUM_TRANSFER_BUFS; i++) { if (strmh-&gt;transfers[i] != NULL) break; } if (i == LIBUVC_NUM_TRANSFER_BUFS) break; pthread_cond_wait(&amp;strmh-&gt;cb_cond, &amp;strmh-&gt;cb_mutex); } 这里会一直循环等待所有流转换器都释放置空完成，而问题就在于偏偏有个别流转换器就是无法正常释放。 为什么没有正常释放完成，是因为libusb_cancel_transfer失败返回LIBUSB_ERROR_NOT_FOUND的状态时，转换器持有无效的buffer和指针，导致上面的循环代码一直不往下走。 一般释放正常时的Log如下： 1234[4632*stream.c:989:_uvc_stream_callback]:not retrying transfer, status = 3[4632*stream.c:629:_uvc_delete_transfer]:begin[4632*stream.c:642:_uvc_delete_transfer]:Freeing transfer 5 (0x72fdbe5960)[4632*stream.c:656:_uvc_delete_transfer]:end 但函数阻塞住时，我发现并没有看到index为6的transfer执行delete的Log，于是我怀疑是否跟transfer的数量有关。 这时查看源码里有一个transfer buffers的数量定义如下： 12345678910libuvc/libuvc_internal.h/* set a high number of transfer buffers. This uses a lot of ram, but avoids problems with scheduling delays on slow boards causing missed transfers. A better approach may be to make the transfer thread FIFO scheduled (if we have root). We could/should change this to allow reduce it to, say, 5 by default and then allow the user to change the number of buffers as required. */#define LIBUVC_NUM_TRANSFER_BUFS 10 如果设置得太高，不仅会提高内存的占用，在处理速度慢的板子上也会有transfer浪费掉。这里我尝试降低数量值为5，再次调试开关100次，stopPreview卡死的问题不再复现。 2.JNI DETECTED ERROR IN APPLICATION: jmethodID was NULL 空指针由于java上层设置setFrameCallback(null, 0); iframecallback_fields.onFrame在另外一个线程被置为NULL而以下这段代码没有判空，导致的空指针：env-&gt;CallVoidMethod(mFrameCallbackObj, iframecallback_fields.onFrame, buf); 解决方法为增加空指针判断如下 1234567void UVCPreview::do_capture_callback(JNIEnv *env, uvc_frame_t *frame){...+if (iframecallback_fields.onFrame != NULL) { env-&gt;CallVoidMethod(mFrameCallbackObj, iframecallback_fields.onFrame, buf);+}...} 3.UVCCamera could not open camera:err=-99要检查打开的usb设备是否已经被其他进程打开了/其他进程持有没释放/打开的是不是UVC摄像头，是否打开了错误的其他usb设备 4.其他一些别人发现的bug和修复方法https://github.com/saki4510t/UVCCamera/pull/520https://github.com/saki4510t/UVCCamera/pull/328","link":"/2019/08/27/uvccamera/android_uvccamera_experience_and_bug/"},{"title":"Zbar的使用建议及如何回避存在的Bug","text":"Zbar是一个很强大的开源二维码/条码识别库，但使用时也有几个需要注意的点，以下列出我在使用Zbar 1.0.0版本时得出的经验。 Zbar的使用建议1.减少一帧的识别时间这里不去谈设备性能的差异。单从识别角度说，Zbar识别一帧的时间跟图像帧里码复杂度、帧尺寸大小、需要判断的码类型数量有关，越复杂的二维码/条码和越大尺寸的图像，识别就会越花时间，建议如下： 将二维码和条码从图像帧中截取出来 缩小Camera预览返回的帧尺寸 在Zbar ImageScanner的初始化设置减少识别的条码类型 将Camera预览调成黑白（有可能对识别彩色二维码有影响） 如果机器是多核CPU，可以开多几个线程进行识别操作 另外注意zbar编译时别选择debug版的，debug版的会比release版的慢很多。 2.提高识别成功率Zbar的识别成功率跟图像帧本身的质量有很大关系，图像帧里二维码/条码越是清晰突出，识别成功率越高，同时要避免减低成功率的操作，建议如下： 将Zbar ImageScanner的X、Y轴扫码密度改为1，这同时会加长识别时间12ImageScanner.setConfig(0, ZBAR_CFG_X_DENSITY, 1);ImageScanner.setConfig(0, ZBAR_CFG_Y_DENSITY, 1); 提高Camera预览的图像对比度 对图像帧进行一些处理，如去除噪点，锐化，这里不提二值化因为Zbar自身带了二值化处理 提高图像帧的质量，突出二维码/条码对Zbar识别是很有帮助的，但有些处理也挺耗时的，所以一旦图像处理时间远超Zbar识别时间而且无法接受，那你就得考虑优化处理或者不做处理。 Zbar存在的Bug识别校验码错误的条形码时会返回错误的结果有些类型的条形码是有校验码，比如Code128类型的。绝大部分时候我们扫码时的条码校验码是没问题的，但一旦真的出现校验码错误的条码时，Zbar能保证完全不出错吗，答案是不能保证。Zbar多次识别校验码错误的条码会返回错误的结果，下面举个例子。 我们可以通过修改ZXing的Code128Writer.java类生成校验码错误的Code128条码。 比如下面这张图片是内容为 “66281303A60.2#$@” 的Code128类型条码图： 而这一张是同样内容但校验码错误的条码图： 如果你用Zbar轮流识别这两张图，会发现识别校验码错误图时有概率会返回结果（实际校验码错误就不应该返回任何结果，而Zbar在解析条码也是有判断校验码的），比如会返回 “66281303A60.1#$@” 或者其他数字组合，不但返回了结果还是返回错误内容的结果。但Zbar也会告诉你quality只有1，所以你也可以根据quality不拿这个结果当是正确的结果，但很多时候Zbar的识别不够突出的条码时返回的也是1。&nbsp;解决方式：其实Zbar一开始识别校验码错误的条码是不会出BUG的，但是反复识别就很容易出现，我们可以过一段时间甚至每次识别就重新初始化Scanner和Image，也需要重新设置初始化选项，这样就大大减少出这个BUG的概率。","link":"/2018/12/13/zbar/zbar_usage_and_bug/"},{"title":"解决Zbar倾斜二维码/条形码识别不出来的情况","text":"在使用Zbar的过程中，有时会遇到二维码/条形码倾斜45%时识别不出来的情况，然而这并不是Zbar的Bug，下面给出两种解决办法。 通过修改Zbar的扫描密度设置（推荐）Zbar在对图像识别时会逐行逐列地扫描，扫描初始化设置里提供了X轴和Y轴的扫描密度的设置，将密度值设置为1，即不跨行扫描，就可以正常识别倾斜的二维码/条形码。 12ImageScanner.setConfig(0, ZBAR_CFG_X_DENSITY, 1);ImageScanner.setConfig(0, ZBAR_CFG_Y_DENSITY, 1); 注意，这里涉及到一个识别速度的问题，很多人将这个值设置为2甚至3，就是为了可以加快识别一帧图像的速度。因为设置为2时，每2行才扫描1行，识别时间更短了，但这也会丢失细节，导致倾斜二维码识别不出来。大部分情况下，Zbar识别一帧图像的时间小于1秒，为了加快一倍的识别速度，丢失识别成功率是不值得的。 使用JNI调用Zbar的情况，要注意检查Java和C代码里对Zbar的初始化设置有没有问题。 通过图像处理矫正再识别将图像矫正再丢给Zbar识别，也是可以的。很多人会使用OpenCV进行图像矫正，这里提供一个处理过程： resize（图像尺寸缩小）-&gt;threshold（二值化）-&gt;erode（几次膨胀腐蚀）-&gt;HoughLines（寻找直线）-&gt;筛除出二维码/一维码的边线，计算出边线的倾斜角度-&gt;warpAffine（对原图像进行仿射变换） 处理后再将图像丢给Zbar识别即可，OpenCV相关代码网上很多，这里就不贴了。 &nbsp;综上所述，这里还是推荐第一种方式。如果还是识别不出来，也许就是图像帧的质量问题，毕竟你觉得清晰的图像，Zbar并不一定觉得细节清晰。","link":"/2018/12/24/zbar/zbar_correct_recognize/"},{"title":"JAVA根证书验证用户证书是否可信和解密数据","text":"一般用户证书和加密数据是一起发放到客户端的，但是使用用户证书的公钥解密数据前需要验证用户证书是否可信，即从源头来说是否由根证书签发的，按证书链去认证。使用根证书验证用户证书可信并解密的Java实现如下： 1.读取根证书文件初始化根证书对象，并获取根证书中的公钥 123CertificateFactory certificateFactory = CertificateFactory.getInstance(\"X.509\");Certificate rootCert = certificateFactory.generateCertificate(new FileInputStream(rootCertPath));PublicKey rootCertPublicKey = rootCert.getPublicKey(); 2.使用用户证书byte数组数据初始化用户证书对象 12X509Certificate userCert = (X509Certificate)certificateFactory.generateCertificate( new ByteArrayInputStream(userCertByteArray)); 3.使用用户证书验证根证书的公钥，如果验证通过（即不抛出Exception）说明这个用户证书是这个根证书签发的,同时检查用户证书是否有效 12345678try { userCert.verify(rootCertPublicKey); userCert.checkValidity(); Log.d(TAG,\"------------- 工作证书验证成功 -----------\");}catch (Exception e) { Log.d(TAG,\"------------- 工作证书验证失败 -----------\"); } 4.最后使用用户证书的公钥进行解密 1234567891011121314151617try { Cipher cipher = Cipher.getInstance(\"RSA/ECB/NoPadding\"); cipher.init(Cipher.DECRYPT_MODE, userCert); byte[] output = cipher.doFinal(cipherData); return output;} catch (NoSuchAlgorithmException e) { throw new Exception(\"无此解密算法\");} catch (NoSuchPaddingException e) { e.printStackTrace(); return null;} catch (InvalidKeyException e) { throw new Exception(\"解密公钥非法,请检查\");} catch (IllegalBlockSizeException e) { throw new Exception(\"密文长度非法\");} catch (BadPaddingException e) { throw new Exception(\"密文数据已损坏\");}","link":"/2019/08/28/java/java_certificate_verify_and_decript/"},{"title":"谈谈Android地图sdk怎么实现的","text":"国内国外有不少在Android平台上提供地图sdk的公司。大部分人使用的地图sdk里，国内有百度/高德地图，国外有谷歌地图。但是地图服务，包括地图基础绘制/路线/导航/POI/定位等，大部分地图sdk的实现都是大同小异的。这里我不想写解析地图sdk业务逻辑层实现的文章，只谈谈一般人不知道的几个点。 1.MapView是怎么实现的地图显示绘制是地图sdk最基础的部分，用户通过手势滑动放大缩小地图，在地图的基础上显示两点间的路线，地图上的商户poi点显示标注等等都要基于MapView去绘制显示。 地图绘制 先说地图的绘制，Android自带OpenGL开放图形库，支持2D,3D矢量图形的绘制。OpenGL ES 是Android绘图API。 OpenGL ES在Android上常用来做游戏开发，所以用来做2d,3d地图的绘制是绝对胜任的。 地图贴图是地图公司收集地图数据绘制出来的，一般都是公司的机密，所以地图sdk在地图绘制上的代码都是在用c/c++代码写的，在Android平台上封装成so库，让java上层只起到一个传递数据/控制/显示的功能。 对于OpenGL这个图形引擎，地图贴图就是一张张的纹理。由地图基础引擎从本地动态加载地图图片到内存，最后使用OpenGL绘制到画布上。 地图控制 OpenGL除了基础的绘制外，也提供了6种坐标系，用户的手势操作最终都会投影到模型和相机视角的变换上。 地图显示 OpenGL ES是平台通用的，在特定设备上使用需要一个中间层做适配，这个中间层就是EGL。 Display(EGLDisplay) 是对实际显示设备的抽象。Surface（EGLSurface）是对用来存储图像的内存区域 FrameBuffer 的抽象，包括 Color Buffer， Stencil Buffer ，Depth Buffer。Context (EGLContext) 存储 OpenGL ES绘图的一些状态信息。 关于EGL的详细我就不描述了，简明扼要的说，我们要绘制地图，用OpenGL ES提供的API去绘制，绘制数据的容器是Surface，绘制数据要在哪个View上显示？Android提供了GLSurfaceView。 GLSurfaceView从Android 1.5(API level 3)开始加入，继承自SurfaceView，实现了SurfaceHolder.Callback2接口，拥有SurfaceView的全部特性，也有view所有的功能和属性，特别是处理事件的能力，它主要是在SurfaceView的基础上它加入了EGL的管理，并自带了一个GLThread绘制线程（EGLContext创建GL环境所在线程即为GL线程），绘制的工作直接通过OpenGL在绘制线程进行，不会阻塞主线程，绘制的结果输出到SurfaceView所提供的Surface上，这使得GLSurfaceView也拥有了OpenGlES所提供的图形处理能力 如果你反编译地图sdk就会发现，不看外面的API封装，MapView基本都是继承GLSurfaceView类实现的。 因为GLSurfaceView拥有SurfaceView的全部特性，所以大部分地图SDK的MapView一旦放到ScrollView里拖动时就会产生黑影。 当然GLSurfaceView并不是必要的，比如有些人用TextureView模仿GLSurfaceView添加EGL实现了GLThread。也同样可以在GLTextureView上进行OpenGL的绘制显示。但GLSurfaceView在地图绘制的场景下更合适，而且从Android 1.5就支持了，剩下的就不比对了，大家可以搜下SurfaceView和TextureView的优劣。 2.路线规划/导航/POI搜索 关于路线/交通状况/POI的数据 路线/交通状况/POI点的数据实际都是保存在后台服务器的，因为这些也是地图公司持有的资源。 地图SDK提供的路线规划/POI搜索/路况显示等功能，实际都是通过网络请求从服务器获取数据，然后通过地图引擎显示在MapView上的。 当然路线的规划也是由后台服务器计算规划出来的，本地通过两个坐标点让服务器计算，服务器返回几条可行的路线数据（包括时间最优，距离最优，少步行等），Android本地只是显示这些服务器返回的结果而已。 关于导航模式 导航也是基于MapView的，只不过是业务场景比较复杂而已。路况/路线模拟图/方向/红绿灯提醒/车速等等，导航模式里涉及到数据比较多，跟服务器的交互也比较频繁。 Android地图的UI，有OpenGL绘制的部分,也有Android View上层绘制的部分。导航数据相关的部分很多是后者。 以上只是我所知道的几个点，当然有很多我没有提及，以后有机会再补充，包括地图公司一般都有自己的导航路线模拟工具，所以测试时可以记录之前行走的路线再次模拟导航，也可以自动模拟导航来触发bug。当然离开地图公司后也没什么机会再接触到相关的代码了，所以就写下这篇文章简单记录下吧。","link":"/2017/07/15/android_map/android_map_understanding/"}],"tags":[{"name":"Android Driver","slug":"Android-Driver","link":"/tags/Android-Driver/"},{"name":"SPRD","slug":"SPRD","link":"/tags/SPRD/"},{"name":"Key","slug":"Key","link":"/tags/Key/"},{"name":"Android KitKat","slug":"Android-KitKat","link":"/tags/Android-KitKat/"},{"name":"Android Kernel","slug":"Android-Kernel","link":"/tags/Android-Kernel/"},{"name":"Android Camera Driver","slug":"Android-Camera-Driver","link":"/tags/Android-Camera-Driver/"},{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"PhoneNumber WhiteList","slug":"PhoneNumber-WhiteList","link":"/tags/PhoneNumber-WhiteList/"},{"name":"Android Java framework","slug":"Android-Java-framework","link":"/tags/Android-Java-framework/"},{"name":"Android System","slug":"Android-System","link":"/tags/Android-System/"},{"name":"Alarm","slug":"Alarm","link":"/tags/Alarm/"},{"name":"Power Save","slug":"Power-Save","link":"/tags/Power-Save/"},{"name":"StartUp","slug":"StartUp","link":"/tags/StartUp/"},{"name":"Boot Flow","slug":"Boot-Flow","link":"/tags/Boot-Flow/"},{"name":"OpenCV","slug":"OpenCV","link":"/tags/OpenCV/"},{"name":"Android OpenGL","slug":"Android-OpenGL","link":"/tags/Android-OpenGL/"},{"name":"Android System App","slug":"Android-System-App","link":"/tags/Android-System-App/"},{"name":"Incall","slug":"Incall","link":"/tags/Incall/"},{"name":"Dialer","slug":"Dialer","link":"/tags/Dialer/"},{"name":"Video Call","slug":"Video-Call","link":"/tags/Video-Call/"},{"name":"UVCCamera","slug":"UVCCamera","link":"/tags/UVCCamera/"},{"name":"libuvc","slug":"libuvc","link":"/tags/libuvc/"},{"name":"Zbar","slug":"Zbar","link":"/tags/Zbar/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Certificate Verify","slug":"Certificate-Verify","link":"/tags/Certificate-Verify/"},{"name":"Decript","slug":"Decript","link":"/tags/Decript/"},{"name":"Android Map","slug":"Android-Map","link":"/tags/Android-Map/"},{"name":"MapView","slug":"MapView","link":"/tags/MapView/"},{"name":"Map SDK","slug":"Map-SDK","link":"/tags/Map-SDK/"}],"categories":[{"name":"Android Driver","slug":"Android-Driver","link":"/categories/Android-Driver/"},{"name":"Android System","slug":"Android-System","link":"/categories/Android-System/"},{"name":"Android Java framework","slug":"Android-Java-framework","link":"/categories/Android-Java-framework/"},{"name":"OpenCV","slug":"OpenCV","link":"/categories/OpenCV/"},{"name":"OpenGL","slug":"OpenGL","link":"/categories/OpenGL/"},{"name":"Android System App","slug":"Android-System-App","link":"/categories/Android-System-App/"},{"name":"Android UVCCamera/libuvc","slug":"Android-UVCCamera-libuvc","link":"/categories/Android-UVCCamera-libuvc/"},{"name":"Zbar","slug":"Zbar","link":"/categories/Zbar/"},{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"Android Map","slug":"Android-Map","link":"/categories/Android-Map/"}]}